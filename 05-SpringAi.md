# ğŸš€ SPRING AI: DO ZERO AO PROFISSIONAL
## O Guia Definitivo para Desenvolvedores

### Por que este e-book Ã© diferente?

VocÃª estÃ¡ prestes a embarcar em uma jornada que transformarÃ¡ vocÃª de curioso sobre IA para um desenvolvedor capaz de criar aplicaÃ§Ãµes inteligentes de nÃ­vel empresarial usando Spring AI. Este nÃ£o Ã© mais um tutorial tÃ©cnico seco - Ã© um roteiro completo, testado em batalha, que combina teoria sÃ³lida com prÃ¡tica intensiva.

---

## ğŸ“‘ SUMÃRIO NAVEGÃVEL

### ğŸŒ± PARTE I: FUNDAMENTOS (NÃ­vel Iniciante)

#### [CapÃ­tulo 1: A RevoluÃ§Ã£o da IA no Ecossistema Spring](#capÃ­tulo-1) â±ï¸ 25 min
- 1.1 O que Ã© Spring AI e por que vocÃª deveria se importar
- 1.2 A evoluÃ§Ã£o: de JDBC a IA
- 1.3 Casos de uso reais que vÃ£o te inspirar
- 1.4 Arquitetura de alto nÃ­vel

#### [CapÃ­tulo 2: Preparando Seu Arsenal de Desenvolvimento](#capÃ­tulo-2) â±ï¸ 35 min
- 2.1 Checklist de prÃ©-requisitos
- 2.2 ConfiguraÃ§Ã£o do ambiente passo a passo
- 2.3 Seu primeiro projeto Spring AI
- 2.4 Troubleshooting de instalaÃ§Ã£o

#### [CapÃ­tulo 3: Hello World Inteligente](#capÃ­tulo-3) â±ï¸ 30 min
- 3.1 Anatomia de uma aplicaÃ§Ã£o Spring AI
- 3.2 Seu primeiro chatbot em 15 minutos
- 3.3 Entendendo o que aconteceu nos bastidores
- 3.4 Expandindo o exemplo bÃ¡sico

#### CapÃ­tulo 4: Os Pilares Fundamentais â±ï¸ 40 min
- 4.1 Models: O cÃ©rebro da operaÃ§Ã£o
- 4.2 Prompts: A arte de fazer perguntas
- 4.3 Tokens: A moeda da IA
- 4.4 Responses: Interpretando as respostas

### ğŸŒ¿ PARTE II: INTERMEDIÃRIO (Construindo AplicaÃ§Ãµes Reais)

#### CapÃ­tulo 5: Orquestrando MÃºltiplos LLMs â±ï¸ 45 min
- 5.1 OpenAI: O padrÃ£o-ouro
- 5.2 Anthropic Claude: O rival criativo
- 5.3 Ollama: IA local e privada
- 5.4 EstratÃ©gias de fallback e load balancing

#### CapÃ­tulo 6: Vector Stores - A MemÃ³ria da IA â±ï¸ 50 min
- 6.1 Embeddings explicados com analogias
- 6.2 Escolhendo seu Vector Database
- 6.3 ImplementaÃ§Ã£o prÃ¡tica com PGVector
- 6.4 Busca semÃ¢ntica na prÃ¡tica

#### CapÃ­tulo 7: RAG - Turbinando IAs com Seus Dados â±ï¸ 55 min
- 7.1 RAG desmistificado
- 7.2 Document Readers e preparaÃ§Ã£o de dados
- 7.3 Implementando RAG completo
- 7.4 Otimizando relevÃ¢ncia e precisÃ£o

#### CapÃ­tulo 8: Prompt Engineering Profissional â±ï¸ 45 min
- 8.1 Anatomia de um prompt eficaz
- 8.2 Templates e parametrizaÃ§Ã£o
- 8.3 TÃ©cnicas avanÃ§adas (Few-shot, Chain-of-thought)
- 8.4 Biblioteca de prompts reutilizÃ¡veis

#### CapÃ­tulo 9: Streaming e ExperiÃªncia do UsuÃ¡rio â±ï¸ 40 min
- 9.1 Por que streaming Ã© crucial
- 9.2 ImplementaÃ§Ã£o com Server-Sent Events
- 9.3 Gerenciamento de contexto e memÃ³ria
- 9.4 UI responsiva com Spring AI

### ğŸŒ³ PARTE III: AVANÃ‡ADO (NÃ­vel Profissional)

#### CapÃ­tulo 10: Function Calling - IAs que Agem â±ï¸ 60 min
- 10.1 O conceito de Tools e Functions
- 10.2 Criando ferramentas customizadas
- 10.3 OrquestraÃ§Ã£o de mÃºltiplas funÃ§Ãµes
- 10.4 Casos de uso empresariais

#### CapÃ­tulo 11: Fine-tuning e CustomizaÃ§Ã£o â±ï¸ 50 min
- 11.1 Quando fine-tuning faz sentido
- 11.2 PreparaÃ§Ã£o de datasets
- 11.3 Processo de fine-tuning
- 11.4 AvaliaÃ§Ã£o de modelos customizados

#### CapÃ­tulo 12: Performance, Custos e Escalabilidade â±ï¸ 55 min
- 12.1 Monitoramento e observabilidade
- 12.2 EstratÃ©gias de cache inteligente
- 12.3 OtimizaÃ§Ã£o de custos de API
- 12.4 Escalando horizontalmente

#### CapÃ­tulo 13: SeguranÃ§a e ProduÃ§Ã£o â±ï¸ 50 min
- 13.1 ProteÃ§Ã£o contra prompt injection
- 13.2 Gerenciamento seguro de API keys
- 13.3 Compliance e governanÃ§a
- 13.4 Checklist de produÃ§Ã£o

### ğŸ¯ PARTE IV: MAESTRIA (Projeto Final)

#### CapÃ­tulo 14: Projeto Completo - Sistema de Atendimento IA â±ï¸ 90 min
- 14.1 Arquitetura do sistema
- 14.2 ImplementaÃ§Ã£o passo a passo
- 14.3 Deploy e monitoramento
- 14.4 Melhorias e prÃ³ximos passos

#### CapÃ­tulo 15: Recursos e Comunidade â±ï¸ 20 min
- 15.1 DocumentaÃ§Ã£o e referÃªncias
- 15.2 Comunidades e fÃ³runs
- 15.3 Mantendo-se atualizado
- 15.4 Contribuindo para o ecossistema

### ğŸ“š RECURSOS ADICIONAIS
- GlossÃ¡rio Completo
- Ãndice Remissivo
- Tabela de ComparaÃ§Ã£o de LLMs
- Troubleshooting Guide
- Snippets de CÃ³digo ReutilizÃ¡veis

---

## ğŸ“ COMO USAR ESTE E-BOOK

### Para Iniciantes Absolutos
ğŸ‘‰ Siga sequencialmente do CapÃ­tulo 1 ao 9. NÃ£o pule etapas!

### Para Desenvolvedores Spring Experientes
ğŸ‘‰ Leia rapidamente os CapÃ­tulos 1-3, foque de 4 em diante.

### Para Profissionais Buscando EspecializaÃ§Ã£o
ğŸ‘‰ Use como referÃªncia, focando nos CapÃ­tulos 10-13.

### Projeto Unificador
Ao longo do e-book, construiremos **"DocBot"** - um assistente inteligente de documentaÃ§Ã£o que evolui de um chatbot simples para um sistema completo com RAG, function calling e interface profissional.

---

<div style="page-break-after: always;"></div>

<a name="capÃ­tulo-1"></a>

# ğŸ“˜ CAPÃTULO 1: A REVOLUÃ‡ÃƒO DA IA NO ECOSSISTEMA SPRING

â±ï¸ **Tempo estimado:** 25 minutos

## ğŸ¯ O QUE VOCÃŠ VAI DOMINAR

Ao final deste capÃ­tulo, vocÃª serÃ¡ capaz de:

- âœ… Explicar o que Ã© Spring AI e seu propÃ³sito no ecossistema Java
- âœ… Identificar casos de uso ideais para Spring AI
- âœ… Compreender a arquitetura de alto nÃ­vel e componentes principais
- âœ… Situar Spring AI no contexto da evoluÃ§Ã£o do Spring Framework
- âœ… Tomar decisÃµes informadas sobre quando usar Spring AI

## ğŸ§  CONCEITO EM 30 SEGUNDOS

Spring AI Ã© a ponte que conecta o robusto ecossistema Spring/Java com o mundo dos Large Language Models (LLMs).

**Pense assim:** se Spring Data facilitou drasticamente o trabalho com bancos de dados, Spring AI faz o mesmo com inteligÃªncia artificial - abstraindo complexidades, fornecendo padrÃµes e permitindo que vocÃª foque na lÃ³gica de negÃ³cio.

---

<a name="1-1"></a>

## ğŸ“– 1.1 O QUE Ã‰ SPRING AI E POR QUE VOCÃŠ DEVERIA SE IMPORTAR

### ğŸ¨ A Analogia do Tradutor Universal

Imagine que vocÃª precisa conversar com pessoas de 20 paÃ­ses diferentes. Sem um tradutor, vocÃª precisaria:

1. Aprender 20 idiomas
2. Entender 20 culturas diferentes
3. Memorizar 20 conjuntos de regras de etiqueta

Um tradutor universal resolve isso, permitindo que vocÃª fale sua lÃ­ngua nativa enquanto ele cuida da comunicaÃ§Ã£o.

**Spring AI Ã© exatamente isso para o mundo da IA:**

```
Seu cÃ³digo Java limpo
        â†“
   [Spring AI] â† O tradutor universal
        â†“
OpenAI, Claude, Gemini, Ollama, etc.
```

### ğŸ”¬ DefiniÃ§Ã£o TÃ©cnica Formal

**Spring AI** Ã© um framework de aplicaÃ§Ã£o que fornece abstraÃ§Ãµes Spring idiomÃ¡ticas e portÃ¡veis para desenvolver aplicaÃ§Ãµes alimentadas por IA Generativa. Ele oferece:

- AbstraÃ§Ãµes de alto nÃ­vel sobre modelos de IA (ChatClient, ImageClient, EmbeddingClient)
- IntegraÃ§Ãµes prontas com principais provedores de LLM
- Componentes especializados para RAG, Vector Stores e Function Calling
- PadrÃµes Spring familiares (Dependency Injection, ConfiguraÃ§Ã£o, etc.)

### ğŸ’¡ Por Que Isso Importa?

**Sem Spring AI:**

```java
// CÃ³digo hipotÃ©tico verboso e acoplado
OkHttpClient client = new OkHttpClient();
Request request = new Request.Builder()
    .url("https://api.openai.com/v1/chat/completions")
    .addHeader("Authorization", "Bearer " + API_KEY)
    .post(RequestBody.create(
        MediaType.parse("application/json"),
        "{\"model\":\"gpt-4\",\"messages\":[{\"role\":\"user\",\"content\":\"OlÃ¡\"}]}"
    ))
    .build();

Response response = client.newCall(request).execute();
String json = response.body().string();
// Agora parse manualmente o JSON, trate erros, retry, etc...
```

**Com Spring AI:**

```java
// CÃ³digo limpo, testÃ¡vel e manutenÃ­vel
@Service
public class ChatService {
    private final ChatClient chatClient;
    
    public ChatService(ChatClient chatClient) {
        this.chatClient = chatClient;
    }
    
    public String chat(String mensagem) {
        return chatClient.call(mensagem);
    }
}
```

### ğŸ“Š BenefÃ­cios MensurÃ¡veis

| Aspecto | Sem Spring AI | Com Spring AI |
|---------|---------------|---------------|
| Linhas de cÃ³digo | ~200 linhas | ~20 linhas |
| Tempo de setup | 2-3 dias | 30 minutos |
| Trocar de LLM | Reescrever tudo | Mudar configuraÃ§Ã£o |
| Testabilidade | Complexa | Simples (mocks prontos) |
| Manutenibilidade | Baixa | Alta |

---

<a name="1-2"></a>

## ğŸ”„ 1.2 A EVOLUÃ‡ÃƒO: DE JDBC A IA

### ğŸ­ HistÃ³ria com Contexto

Para entender o valor do Spring AI, vamos fazer uma viagem no tempo:

#### ğŸ“… Anos 2000: A Era do JDBC Puro

```java
// O pesadelo que era trabalhar com banco de dados
Connection conn = null;
PreparedStatement stmt = null;
ResultSet rs = null;
try {
    Class.forName("com.mysql.jdbc.Driver");
    conn = DriverManager.getConnection(DB_URL, USER, PASS);
    stmt = conn.prepareStatement("SELECT * FROM users WHERE id = ?");
    stmt.setInt(1, userId);
    rs = stmt.executeQuery();
    while(rs.next()) {
        // processar...
    }
} catch(SQLException e) {
    e.printStackTrace();
} finally {
    try { if(rs != null) rs.close(); } catch(Exception e) {}
    try { if(stmt != null) stmt.close(); } catch(Exception e) {}
    try { if(conn != null) conn.close(); } catch(Exception e) {}
}
```

#### ğŸ“… Anos 2010: Spring Data Revoluciona

```java
// Mesma funcionalidade, cÃ³digo elegante
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findById(Long id);
}

// Uso:
User user = userRepository.findById(userId).orElseThrow();
```

#### ğŸ“… Anos 2020: O Desafio da IA

Desenvolvedores enfrentaram os mesmos problemas com APIs de IA:
- CÃ³digos boilerplate repetitivos
- Acoplamento forte com provedores
- Falta de padronizaÃ§Ã£o
- Dificuldade de testes

#### ğŸ“… 2023+: Spring AI ao Resgate

```java
// A mesma revoluÃ§Ã£o, agora para IA
@Service
public class AssistenteIA {
    private final ChatClient chatClient;
    
    public String responder(String pergunta) {
        return chatClient.call(pergunta);
    }
}
```

### ğŸ“ˆ O PadrÃ£o Spring Aplicado Ã  IA

| Conceito Spring Tradicional | Equivalente Spring AI |
|----------------------------|----------------------|
| JdbcTemplate | ChatClient |
| @Repository | @Component com AI Clients |
| DataSource | Model Configuration |
| JPA Entities | POJOs com AI annotations |
| Transactions | Conversational Memory |

---

<a name="1-3"></a>

## ğŸ’¼ 1.3 CASOS DE USO REAIS QUE VÃƒO TE INSPIRAR

### ğŸ¯ Mapeamento: Problema â†’ SoluÃ§Ã£o Spring AI

#### 1. Atendimento ao Cliente Inteligente

**Problema Real:** Empresa recebe 10.000 tickets/dia, 70% sÃ£o perguntas repetitivas.

**SoluÃ§Ã£o Spring AI:**

```java
@Service
public class SupportBot {
    private final ChatClient chatClient;
    private final VectorStore knowledgeBase;
    
    public String responderTicket(String pergunta) {
        // Busca documentaÃ§Ã£o relevante (RAG)
        List<Document> docs = knowledgeBase.similaritySearch(pergunta);
        
        // Gera resposta contextualizada
        String contexto = docs.stream()
            .map(Document::getContent)
            .collect(Collectors.joining("\n"));
        
        return chatClient.call(new Prompt(
            "Baseando-se nesta documentaÃ§Ã£o: " + contexto + 
            "\n\nResponda: " + pergunta
        ));
    }
}
```

**Resultado:** 60% de reduÃ§Ã£o no tempo de resposta.

#### 2. AnÃ¡lise de Sentimento em Tempo Real

**Problema Real:** Monitorar reputaÃ§Ã£o de marca em redes sociais.

**SoluÃ§Ã£o Spring AI:**

```java
@Service
public class SentimentAnalyzer {
    private final ChatClient chatClient;
    
    public Sentiment analisar(String texto) {
        String prompt = """
            Analise o sentimento do texto a seguir.
            Retorne apenas: POSITIVO, NEGATIVO ou NEUTRO
            
            Texto: %s
            """.formatted(texto);
        
        String resultado = chatClient.call(prompt);
        return Sentiment.valueOf(resultado.trim());
    }
}
```

#### 3. GeraÃ§Ã£o de RelatÃ³rios Executivos

**Problema Real:** Executivos precisam de resumos de relatÃ³rios de 100+ pÃ¡ginas.

**SoluÃ§Ã£o Spring AI:**

```java
@Service
public class ReportSummarizer {
    private final ChatClient chatClient;
    
    public String resumirRelatorio(String relatorioCompleto) {
        return chatClient.call(new Prompt(
            "Resuma este relatÃ³rio em 3 parÃ¡grafos executivos, " +
            "destacando mÃ©tricas principais e aÃ§Ãµes recomendadas:\n\n" +
            relatorioCompleto,
            OpenAiChatOptions.builder()
                .withModel("gpt-4")
                .withTemperature(0.3) // Baixa criatividade, alta precisÃ£o
                .build()
        ));
    }
}
```

#### 4. Assistente de CÃ³digo (Code Review Automatizado)

**Problema Real:** Code reviews atrasam deploys.

**SoluÃ§Ã£o Spring AI:**

```java
@Service
public class CodeReviewer {
    private final ChatClient chatClient;
    
    public List<Suggestion> revisar(String codigo) {
        String prompt = """
            Revise este cÃ³digo Java e retorne sugestÃµes em JSON:
            
            %s
            
            Formato esperado:
            [
              {"linha": 10, "severidade": "ALTA", "mensagem": "..."},
              ...
            ]
            """.formatted(codigo);
        
        String json = chatClient.call(prompt);
        return parseToSuggestions(json);
    }
}
```

### ğŸ† Casos de Uso Por Vertical

| IndÃºstria | AplicaÃ§Ã£o Spring AI |
|-----------|---------------------|
| E-commerce | RecomendaÃ§Ãµes personalizadas, chatbots de vendas |
| Financeiro | AnÃ¡lise de risco, detecÃ§Ã£o de fraudes, robo-advisors |
| SaÃºde | Triagem de sintomas, anÃ¡lise de exames (com disclaimers) |
| EducaÃ§Ã£o | Tutores personalizados, correÃ§Ã£o automÃ¡tica |
| JurÃ­dico | AnÃ¡lise de contratos, pesquisa de jurisprudÃªncia |
| RH | Triagem de currÃ­culos, onboarding inteligente |

---

<a name="1-4"></a>

## ğŸ—ï¸ 1.4 ARQUITETURA DE ALTO NÃVEL

### ğŸ¨ VisualizaÃ§Ã£o Conceitual

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  SUA APLICAÃ‡ÃƒO SPRING                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚Controllersâ”‚  â”‚ Services â”‚  â”‚Repositoriesâ”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚        â”‚             â”‚              â”‚                    â”‚
â”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚                      â”‚                                    â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  â”‚
â”‚              SPRING AI LAYER                             â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•  â”‚
â”‚                      â”‚                                    â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚    â”‚       AI Clients Abstraction      â”‚                â”‚
â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                â”‚
â”‚    â”‚  â”‚ChatClientâ”‚  â”‚EmbeddingClientâ”‚  â”‚                â”‚
â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                      â”‚                                    â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚    â”‚    Model Provider Adapters        â”‚                â”‚
â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”‚                â”‚
â”‚    â”‚  â”‚OpenAI  â”‚ â”‚Anthropicâ”‚ â”‚Ollamaâ”‚ â”‚                â”‚
â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜ â”‚                â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              INTERNET / LOCAL
       â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                      â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   LLM APIs / Local Models â”‚
        â”‚  GPT-4 | Claude | Llama   â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ§© Componentes Principais Explicados

#### 1. ChatClient (O CoraÃ§Ã£o)

**Analogia:** Pense no ChatClient como um garÃ§om multilÃ­ngue em um restaurante internacional.

- VocÃª faz o pedido na sua lÃ­ngua (cÃ³digo Java)
- Ele traduz para a "lÃ­ngua da cozinha" (API do LLM)
- Traz a resposta formatada para vocÃª

**Responsabilidades:**
- Gerenciar conversas
- Enviar prompts
- Receber e parsear respostas
- Lidar com erros e retries

#### 2. EmbeddingClient (O BibliotecÃ¡rio)

**Analogia:** Um bibliotecÃ¡rio que organiza livros por similaridade de conteÃºdo, nÃ£o por ordem alfabÃ©tica.

- Transforma texto em vetores numÃ©ricos
- Permite busca semÃ¢ntica ("conceito similar" vs "palavra exata")

**Uso TÃ­pico:**

```java
List<Double> vetor = embeddingClient.embed("Spring Boot Ã© incrÃ­vel");
// Retorna: [0.234, -0.891, 0.456, ...] (1536 dimensÃµes)
```

#### 3. VectorStore (A MemÃ³ria de Longo Prazo)

**Analogia:** Um arquivo cerebral que lembra de tudo que vocÃª jÃ¡ disse e encontra informaÃ§Ãµes relacionadas instantaneamente.

**Componentes:**
- **Armazenamento:** PostgreSQL com PGVector, ChromaDB, Pinecone
- **Busca:** Similaridade por distÃ¢ncia coseno/euclidiana
- **IntegraÃ§Ã£o:** Alimenta sistemas RAG

#### 4. Document Readers (Os Tradutores de Formato)

**Analogia:** Conversores que transformam qualquer tipo de arquivo em texto compreensÃ­vel.

**Suporta:**
- PDF, DOCX, TXT
- JSON, CSV
- PÃ¡ginas web (HTML)
- Imagens (via OCR com integraÃ§Ãµes)

#### 5. OutputParsers (Os Organizadores)

**Analogia:** Assistentes que pegam resposta bagunÃ§ada da IA e organizam em estruturas Java.

**Exemplo:**

```java
// IA retorna: "Nome: JoÃ£o, Idade: 30, Cidade: SÃ£o Paulo"
// OutputParser converte automaticamente para:
Pessoa pessoa = new Pessoa("JoÃ£o", 30, "SÃ£o Paulo");
```

### ğŸ”„ Fluxo de Dados TÃ­pico

```mermaid
graph LR
    A[UsuÃ¡rio faz pergunta] --> B[Controller recebe]
    B --> C[Service processa]
    C --> D{Precisa de contexto?}
    D -->|Sim| E[VectorStore busca docs relevantes]
    D -->|NÃ£o| F[ChatClient envia prompt]
    E --> F
    F --> G[LLM processa]
    G --> H[Resposta retorna]
    H --> I[OutputParser formata]
    I --> J[Controller retorna ao usuÃ¡rio]
```

---

## âš ï¸ ARMADILHAS COMUNS

### âŒ Erro 1: Achar que Spring AI Ã© um LLM

**EquÃ­voco:**

```java
// Spring AI NÃƒO Ã‰ um modelo de IA!
// Ã‰ uma abstraÃ§Ã£o sobre modelos existentes
```

**Realidade:**
- Spring AI = Framework
- GPT-4, Claude, etc. = Modelos
- Spring AI conecta vocÃª aos modelos

### âŒ Erro 2: Ignorar custos de API

**Problema:**

```java
// Isso pode custar CARO!
for(int i = 0; i < 10000; i++) {
    chatClient.call("Analise este texto: " + textos[i]);
}
```

**SoluÃ§Ã£o:**
- Implemente cache
- Use batch processing
- Monitore gastos

### âŒ Erro 3: NÃ£o validar respostas da IA

**Problema:**

```java
String sql = chatClient.call("Gere um SQL para deletar usuÃ¡rios");
jdbcTemplate.execute(sql); // ğŸ”¥ PERIGO!
```

**SoluÃ§Ã£o:**

```java
String sql = chatClient.call("Gere um SQL para deletar usuÃ¡rios");
if(SqlValidator.isSafe(sql) && sql.contains("WHERE")) {
    jdbcTemplate.execute(sql);
} else {
    throw new SecurityException("SQL nÃ£o validado");
}
```

---

## ğŸš€ BOAS PRÃTICAS PROFISSIONAIS

### âœ… 1. Use InjeÃ§Ã£o de DependÃªncia

```java
// âœ… BOM: TestÃ¡vel e desacoplado
@Service
public class MeuServico {
    private final ChatClient chatClient;
    
    @Autowired
    public MeuServico(ChatClient chatClient) {
        this.chatClient = chatClient;
    }
}

// âŒ RUIM: Acoplado e difÃ­cil de testar
@Service
public class MeuServico {
    private ChatClient chatClient = new OpenAiChatClient();
}
```

### âœ… 2. Centralize ConfiguraÃ§Ãµes

```yaml
# application.yml
spring:
  ai:
    openai:
      api-key: ${OPENAI_API_KEY}
      model: gpt-4
      temperature: 0.7
```

```java
@Configuration
public class AiConfig {
    @Bean
    public ChatClient chatClient(
        @Value("${spring.ai.openai.api-key}") String apiKey) {
        // ConfiguraÃ§Ã£o centralizada
    }
}
```

### âœ… 3. Implemente Observabilidade Desde o InÃ­cio

```java
@Service
public class ChatService {
    private final ChatClient chatClient;
    private final MeterRegistry meterRegistry;
    
    public String chat(String mensagem) {
        Timer.Sample sample = Timer.start(meterRegistry);
        try {
            String resposta = chatClient.call(mensagem);
            meterRegistry.counter("ai.chat.success").increment();
            return resposta;
        } catch(Exception e) {
            meterRegistry.counter("ai.chat.error").increment();
            throw e;
        } finally {
            sample.stop(meterRegistry.timer("ai.chat.duration"));
        }
    }
}
```

---

## âœ… CHECKLIST DE DOMÃNIO

Marque conforme dominar cada conceito:

- [ ] Consigo explicar Spring AI para um desenvolvedor jÃºnior
- [ ] Entendo a diferenÃ§a entre Spring AI e os LLMs
- [ ] Sei identificar 3 casos de uso adequados para Spring AI
- [ ] Compreendo o papel de cada componente principal (ChatClient, VectorStore, etc.)
- [ ] ReconheÃ§o as armadilhas comuns e sei evitÃ¡-las
- [ ] Consigo justificar tecnicamente o uso de Spring AI em um projeto

---

## ğŸ”— CONECTANDO OS PONTOS

**O que vimos neste capÃ­tulo:**
- FundaÃ§Ã£o conceitual do Spring AI
- Contexto histÃ³rico e evoluÃ§Ã£o
- Casos de uso prÃ¡ticos reais
- Arquitetura de alto nÃ­vel

**O que vem a seguir (CapÃ­tulo 2):**
- Setup completo do ambiente
- InstalaÃ§Ã£o passo a passo
- Primeiro projeto hands-on

**Como este capÃ­tulo se conecta ao projeto DocBot:**
VocÃª agora entende por que vamos construir o DocBot e quais componentes usaremos. No prÃ³ximo capÃ­tulo, prepararemos o ambiente para comeÃ§ar a codificaÃ§Ã£o.

---

## ğŸ“ RESUMO EM BULLETS

- Spring AI = AbstraÃ§Ã£o sobre APIs de LLM, nÃ£o um modelo prÃ³prio
- BenefÃ­cio principal: CÃ³digo limpo, testÃ¡vel e provider-agnostic
- Componentes-chave: ChatClient, EmbeddingClient, VectorStore, Document Readers
- Casos de uso: Chatbots, RAG, anÃ¡lise de sentimento, geraÃ§Ã£o de conteÃºdo
- Armadilha crÃ­tica: Sempre validar respostas de IA antes de executar aÃ§Ãµes
- PrÃ³ximo passo: Setup do ambiente de desenvolvimento

ğŸ’¡ **DICA PRO:** Salve este capÃ­tulo como referÃªncia. Volte a ele sempre que estiver decidindo se Spring AI Ã© adequado para um novo projeto.

---

<div style="page-break-after: always;"></div>

<a name="capÃ­tulo-2"></a>

# ğŸ› ï¸ CAPÃTULO 2: PREPARANDO SEU ARSENAL DE DESENVOLVIMENTO

â±ï¸ **Tempo estimado:** 35 minutos

## ğŸ¯ O QUE VOCÃŠ VAI DOMINAR

Ao final deste capÃ­tulo, vocÃª serÃ¡ capaz de:

- âœ… Configurar um ambiente completo de desenvolvimento Spring AI do zero
- âœ… Criar e configurar seu primeiro projeto Spring AI usando Spring Initializr
- âœ… Gerenciar credenciais de API de forma segura
- âœ… Resolver os problemas mais comuns de instalaÃ§Ã£o
- âœ… Validar que tudo estÃ¡ funcionando corretamente antes de codar

## ğŸ§  CONCEITO EM 30 SEGUNDOS

Preparar o ambiente de desenvolvimento Ã© como montar uma cozinha profissional antes de cozinhar. VocÃª precisa das ferramentas certas, ingredientes frescos (dependÃªncias) e tudo organizado. Fazer isso corretamente agora economizarÃ¡ horas de frustraÃ§Ã£o depois.

---

<a name="2-1"></a>

## ğŸ“‹ 2.1 CHECKLIST DE PRÃ‰-REQUISITOS

### ğŸ¨ Analogia do Kit de Ferramentas

Imagine que vocÃª vai construir uma casa. Antes de comeÃ§ar, vocÃª precisa:

- âœ… Ferramentas bÃ¡sicas (martelo, serrote)
- âœ… Materiais de construÃ§Ã£o (madeira, pregos)
- âœ… Planta do projeto
- âœ… LicenÃ§as necessÃ¡rias

Da mesma forma, para Spring AI vocÃª precisa:

### ğŸ“¦ 1. Java Development Kit (JDK)

**Por que precisamos?**
Spring AI Ã© construÃ­do em Java/Kotlin. Ã‰ a fundaÃ§Ã£o de tudo.

**VersÃ£o Recomendada:**

```
â˜‘ JDK 17 ou superior (LTS recomendado)
â˜‘ JDK 21 para recursos mais recentes
```

**Como verificar se vocÃª jÃ¡ tem:**

```bash
# No terminal/cmd
java -version
```

**SaÃ­da esperada:**

```
java version "17.0.8" 2023-07-18 LTS
Java(TM) SE Runtime Environment (build 17.0.8+9-LTS-211)
```

**InstalaÃ§Ã£o (se necessÃ¡rio):**

**Windows:**

```bash
# Usando Chocolatey (gerenciador de pacotes)
choco install openjdk17

# OU baixe manualmente de:
# https://adoptium.net/
```

**macOS:**

```bash
# Usando Homebrew
brew install openjdk@17

# Adicione ao PATH (adicione ao ~/.zshrc ou ~/.bash_profile)
echo 'export PATH="/opt/homebrew/opt/openjdk@17/bin:$PATH"' >> ~/.zshrc
```

**Linux (Ubuntu/Debian):**

```bash
sudo apt update
sudo apt install openjdk-17-jdk
```

### ğŸ”¨ 2. Maven ou Gradle

**Por que precisamos?**
Gerenciadores de dependÃªncias - trazem automaticamente todas as bibliotecas que Spring AI precisa.

**VersÃ£o Recomendada:**

```
â˜‘ Maven 3.8+ OU Gradle 7.6+
```

**Como verificar:**

```bash
mvn -version
# OU
gradle -version
```

**InstalaÃ§Ã£o:**

**Maven:**

```bash
# Windows (Chocolatey)
choco install maven

# macOS (Homebrew)
brew install maven

# Linux
sudo apt install maven
```

**Gradle:**

```bash
# Windows (Chocolatey)
choco install gradle

# macOS (Homebrew)
brew install gradle

# Linux
sudo apt install gradle
```

ğŸ’¡ **DICA PRO:** Se vocÃª usa uma IDE moderna (IntelliJ IDEA, Eclipse, VS Code com extensÃµes), elas geralmente incluem Maven/Gradle embutidos. VocÃª pode usar essas versÃµes.

### ğŸ’» 3. IDE (Ambiente de Desenvolvimento)

**OpÃ§Ãµes Recomendadas:**

| IDE | PrÃ³s | Contras | NÃ­vel Recomendado |
|-----|------|---------|-------------------|
| IntelliJ IDEA | Melhor suporte Spring, refactoring poderoso | Pago (versÃ£o Ultimate) | Todos |
| VS Code | Leve, gratuito, extensÃ­vel | Requer configuraÃ§Ã£o manual | IntermediÃ¡rio+ |
| Eclipse | Gratuito, tradicional | Interface menos moderna | Iniciante |

**Setup Recomendado: IntelliJ IDEA Community (Gratuito)**

Download: https://www.jetbrains.com/idea/download/

**Plugins essenciais:**
- Spring Boot (geralmente jÃ¡ vem instalado)
- Lombok (para cÃ³digo mais limpo)
- Rainbow Brackets (facilita leitura de cÃ³digo)

**Instalar plugins:**

```
File â†’ Settings â†’ Plugins â†’ Marketplace â†’ Buscar e instalar
```

### ğŸ”‘ 4. Credenciais de API do LLM

**Por que precisamos?**
Spring AI se conecta a serviÃ§os de IA. VocÃª precisa de uma "chave de acesso" (como senha de WiFi).

#### OpÃ§Ãµes de Provedores:

#### OpÃ§Ã£o 1: OpenAI (Recomendado para iniciantes)

**CaracterÃ­sticas:**
- âœ… Mais popular e documentado
- âœ… GPT-4 e GPT-3.5 disponÃ­veis
- âš ï¸ Pago (mas oferece crÃ©ditos iniciais)

**Como obter:**

1. Acesse https://platform.openai.com/signup
2. Crie uma conta (com Google/email)
3. VÃ¡ para https://platform.openai.com/api-keys
4. Clique em "Create new secret key"
5. **COPIE A CHAVE AGORA** (ela sÃ³ Ã© mostrada uma vez!)
6. Formato da chave: `sk-proj-xxxxxxxxxxxxxxxxxxxxx`

**PreÃ§os (referÃªncia 2024):**
- GPT-3.5-turbo: ~$0.002 / 1K tokens
- GPT-4: ~$0.03 / 1K tokens
- VocÃª recebe $5 de crÃ©dito inicial

#### OpÃ§Ã£o 2: Ollama (Totalmente gratuito e local)

**CaracterÃ­sticas:**
- âœ… 100% gratuito
- âœ… Roda localmente (privacidade total)
- âœ… Sem limites de uso
- âš ï¸ Requer GPU para performance decente
- âš ï¸ Modelos menores (qualidade inferior ao GPT-4)

**Como obter:**

1. Baixe de https://ollama.ai/download
2. Instale (processo simples, next-next-finish)
3. Abra terminal e rode:

```bash
# Baixar modelo Llama 2 (7B)
ollama pull llama2

# Testar
ollama run llama2
>>> OlÃ¡, como vocÃª estÃ¡?
```

ğŸ’¡ **DICA PRO:** Use Ollama para desenvolvimento/testes e OpenAI para produÃ§Ã£o.

#### OpÃ§Ã£o 3: Anthropic Claude (Alternativa premium)

**Como obter:**
1. Acesse https://console.anthropic.com/
2. Crie conta
3. Gere API key em Settings â†’ API Keys

**Vantagem:** Melhor em tarefas de raciocÃ­nio complexo.

### ğŸŒ 5. ConexÃ£o com Internet EstÃ¡vel

- NecessÃ¡ria para baixar dependÃªncias
- APIs de LLM requerem conexÃ£o (exceto Ollama)
- Testes iniciais consomem ~500MB de downloads

### ğŸ“Š Checklist Final de PrÃ©-requisitos

Antes de prosseguir, confirme:

```
â˜ JDK 17+ instalado e funcionando
â˜ Maven/Gradle instalado
â˜ IDE configurada com plugins Spring
â˜ Pelo menos UMA chave de API de LLM (OpenAI ou outra)
â˜ ConexÃ£o estÃ¡vel com internet
â˜ Pelo menos 2GB de espaÃ§o em disco livre
```

---

<a name="2-2"></a>

## ğŸš€ 2.2 CONFIGURAÃ‡ÃƒO DO AMBIENTE PASSO A PASSO

### ğŸ¨ Analogia: Construindo as FundaÃ§Ãµes

Agora que temos as ferramentas, vamos construir a fundaÃ§Ã£o da casa. Vamos criar um projeto Spring Boot configurado especificamente para IA.

### ğŸ“ MÃ©todo 1: Spring Initializr (Recomendado para Iniciantes)

#### Passo 1: Acessar o Initializr

Abra no navegador: **https://start.spring.io/**

#### Passo 2: ConfiguraÃ§Ã£o do Projeto

Preencha exatamente assim (primeira vez):

```
Project: [â—] Maven  [ ] Gradle
Language: [â—] Java  [ ] Kotlin  [ ] Groovy
Spring Boot: 3.2.0 (ou mais recente estÃ¡vel)

Project Metadata:
â”œâ”€ Group: com.seudominio
â”œâ”€ Artifact: docbot-ai
â”œâ”€ Name: DocBot AI
â”œâ”€ Description: Sistema inteligente de documentaÃ§Ã£o
â”œâ”€ Package name: com.seudominio.docbot
â””â”€ Packaging: [â—] Jar  [ ] War
   Java: [â—] 17  [ ] 21
```

#### Passo 3: Adicionar DependÃªncias

Clique em **"ADD DEPENDENCIES"** e adicione:

```
1. Spring Web
   (Para criar APIs REST)

2. Spring AI OpenAI
   (Cliente OpenAI integrado)

3. Spring Boot DevTools
   (ReinicializaÃ§Ã£o automÃ¡tica durante desenvolvimento)

4. Lombok (Opcional mas recomendado)
   (Reduz boilerplate de cÃ³digo)
```

**Como adicionar:**
1. Clique no botÃ£o "ADD DEPENDENCIES..."
2. Digite o nome (ex: "Spring Web")
3. Clique na dependÃªncia que aparece

#### Passo 4: Gerar o Projeto

1. Clique em **"GENERATE"** (botÃ£o verde inferior)
2. Um arquivo `docbot-ai.zip` serÃ¡ baixado
3. Extraia para uma pasta de projetos (ex: `C:\projetos\` ou `~/projetos/`)

### ğŸ’» MÃ©todo 2: Via IntelliJ IDEA (Alternativa)

#### Passo 1: Novo Projeto

```
File â†’ New â†’ Project
```

#### Passo 2: ConfiguraÃ§Ã£o

```
Generators: [Spring Initializr]

Name: docbot-ai
Location: C:\projetos\docbot-ai
Language: Java
Type: Maven
Group: com.seudominio
Artifact: docbot-ai
JDK: 17

[Next]
```

#### Passo 3: DependÃªncias

```
Spring Boot: 3.2.x

Dependencies:
â˜‘ Web â†’ Spring Web
â˜‘ AI â†’ OpenAI
â˜‘ Developer Tools â†’ Spring Boot DevTools
â˜‘ Developer Tools â†’ Lombok

[Create]
```

### ğŸ“‚ Estrutura do Projeto Gerado

ApÃ³s abrir o projeto na IDE, vocÃª verÃ¡:

```
docbot-ai/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main/
â”‚   â”‚   â”œâ”€â”€ java/
â”‚   â”‚   â”‚   â””â”€â”€ com/seudominio/docbot/
â”‚   â”‚   â”‚       â””â”€â”€ DocBotAiApplication.java  â† Classe principal
â”‚   â”‚   â””â”€â”€ resources/
â”‚   â”‚       â”œâ”€â”€ application.properties  â† ConfiguraÃ§Ãµes
â”‚   â”‚       â””â”€â”€ static/                 â† Arquivos estÃ¡ticos
â”‚   â””â”€â”€ test/
â”‚       â””â”€â”€ java/                       â† Testes
â”œâ”€â”€ pom.xml                             â† DependÃªncias Maven
â””â”€â”€ README.md
```

### ğŸ”§ Passo 4: Configurar Credenciais de API

#### Onde colocar API keys (NUNCA no cÃ³digo!)

Abra: `src/main/resources/application.properties`

Adicione:

```properties
# ConfiguraÃ§Ã£o OpenAI
spring.ai.openai.api-key=${OPENAI_API_KEY}
spring.ai.openai.chat.options.model=gpt-3.5-turbo
spring.ai.openai.chat.options.temperature=0.7
```

**ExplicaÃ§Ã£o linha por linha:**

```properties
# ${OPENAI_API_KEY} - Busca a chave de uma variÃ¡vel de ambiente
# Isso Ã© MUITO mais seguro do que escrever: spring.ai.openai.api-key=sk-xxxxx

# model=gpt-3.5-turbo - Modelo padrÃ£o (mais barato)
# OpÃ§Ãµes: gpt-3.5-turbo, gpt-4, gpt-4-turbo-preview

# temperature=0.7 - Controla "criatividade"
# 0.0 = Respostas determinÃ­sticas e objetivas
# 1.0 = Respostas criativas e variadas
# 0.7 = EquilÃ­brio (padrÃ£o recomendado)
```

### ğŸ” Passo 5: Configurar VariÃ¡vel de Ambiente

âš¡ **ATENÃ‡ÃƒO:** NUNCA commite chaves de API no Git!

#### Windows:

**MÃ©todo 1: TemporÃ¡rio (sessÃ£o atual)**

```bash
# No CMD
set OPENAI_API_KEY=sk-sua-chave-aqui

# No PowerShell
$env:OPENAI_API_KEY="sk-sua-chave-aqui"
```

**MÃ©todo 2: Permanente**

```
1. BotÃ£o direito em "Este Computador" â†’ Propriedades
2. ConfiguraÃ§Ãµes AvanÃ§adas do Sistema
3. VariÃ¡veis de Ambiente
4. Em "VariÃ¡veis do usuÃ¡rio", clique [Novo]
   Nome: OPENAI_API_KEY
   Valor: sk-sua-chave-aqui
5. [OK] â†’ Reinicie a IDE
```

#### macOS/Linux:

Adicione ao arquivo de perfil:

```bash
# Abra o arquivo de perfil
nano ~/.zshrc   # macOS com zsh
# OU
nano ~/.bashrc  # Linux com bash

# Adicione no final:
export OPENAI_API_KEY="sk-sua-chave-aqui"

# Salve (Ctrl+O, Enter, Ctrl+X)

# Aplique as mudanÃ§as
source ~/.zshrc
# OU
source ~/.bashrc
```

**Verificar:**

```bash
echo $OPENAI_API_KEY
# Deve mostrar sua chave
```

#### IntelliJ IDEA: ConfiguraÃ§Ã£o de VariÃ¡veis

Alternativa prÃ¡tica:

```
1. Run â†’ Edit Configurations
2. Selecione sua aplicaÃ§Ã£o
3. Environment Variables â†’ [...]
4. Adicione:
   Name: OPENAI_API_KEY
   Value: sk-sua-chave-aqui
5. [OK]
```

ğŸ’¡ **VANTAGEM:** Chave fica apenas no projeto, nÃ£o afeta sistema todo.

### âœ… Passo 6: Validar ConfiguraÃ§Ã£o

#### Teste 1: Build do Projeto

```bash
# No terminal da IDE (View â†’ Tool Windows â†’ Terminal)
mvn clean install
```

**SaÃ­da esperada:**

```
[INFO] BUILD SUCCESS
[INFO] Total time: 15.234 s
```

âŒ Se der erro: Veja seÃ§Ã£o Troubleshooting.

#### Teste 2: Executar AplicaÃ§Ã£o

**No IntelliJ:**

```
Clique direito em DocBotAiApplication.java â†’ Run 'DocBotAiApplication'
```

**Na linha de comando:**

```bash
mvn spring-boot:run
```

**SaÃ­da esperada:**

```
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v3.2.0)

2024-01-15 10:30:45.123  INFO 12345 --- [main] c.s.d.DocBotAiApplication
: Starting DocBotAiApplication using Java 17
...
2024-01-15 10:30:50.456  INFO 12345 --- [main] o.s.b.w.embedded.tomcat.TomcatWebServer
: Tomcat started on port(s): 8080 (http)
2024-01-15 10:30:50.467  INFO 12345 --- [main] c.s.d.DocBotAiApplication
: Started DocBotAiApplication in 5.821 seconds
```

ğŸ‰ **Se vocÃª viu isso, SUCESSO!** Pressione Ctrl+C para parar.

---

<a name="2-3"></a>

## ğŸ’» 2.3 SEU PRIMEIRO PROJETO SPRING AI

### ğŸ¯ Objetivo

Criar um endpoint REST simples que conversa com ChatGPT e validar que tudo estÃ¡ funcionando.

### ğŸ“ Passo 1: Criar o Controller

**Crie o arquivo:**
`src/main/java/com/seudominio/docbot/controller/ChatController.java`

```java
package com.seudominio.docbot.controller;

import org.springframework.ai.chat.ChatClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

/**
 * Controller REST para interaÃ§Ãµes com IA.
 * 
 * Este Ã© nosso primeiro contato com Spring AI!
 * Vamos criar um endpoint simples que recebe uma pergunta
 * e retorna uma resposta do ChatGPT.
 */
@RestController  // Marca esta classe como um controller REST
public class ChatController {

    // ChatClient Ã© injetado automaticamente pelo Spring
    // Ele jÃ¡ vem configurado com as credenciais do application.properties
    private final ChatClient chatClient;

    // InjeÃ§Ã£o de dependÃªncia via construtor (padrÃ£o recomendado)
    public ChatController(ChatClient chatClient) {
        this.chatClient = chatClient;
    }

    /**
     * Endpoint GET /chat
     * 
     * Exemplo de uso:
     * http://localhost:8080/chat?mensagem=OlÃ¡, como vocÃª estÃ¡?
     * 
     * @param mensagem A pergunta do usuÃ¡rio
     * @return Resposta do ChatGPT
     */
    @GetMapping("/chat")
    public String chat(@RequestParam String mensagem) {
        // Aqui acontece a mÃ¡gica!
        // chatClient.call() envia a mensagem para o ChatGPT
        // e retorna a resposta como String
        return chatClient.call(mensagem);
    }
}
```

### ğŸ”§ Passo 2: Executar a AplicaÃ§Ã£o

```bash
mvn spring-boot:run
```

Aguarde atÃ© ver:

```
Tomcat started on port(s): 8080 (http)
```

### ğŸ§ª Passo 3: Testar o Endpoint

#### MÃ©todo 1: Navegador

Abra no navegador:

```
http://localhost:8080/chat?mensagem=OlÃ¡, como vocÃª estÃ¡?
```

**Resposta esperada:**

```
OlÃ¡! Estou funcionando perfeitamente, obrigado por perguntar. 
Como posso ajudÃ¡-lo hoje?
```

#### MÃ©todo 2: curl (Terminal)

```bash
curl "http://localhost:8080/chat?mensagem=Explique Spring Boot em uma frase"
```

**Resposta esperada:**

```
Spring Boot Ã© um framework Java que simplifica drasticamente 
a criaÃ§Ã£o de aplicaÃ§Ãµes robustas com configuraÃ§Ã£o mÃ­nima.
```

#### MÃ©todo 3: Postman/Insomnia

```
GET http://localhost:8080/chat
Query Params:
  mensagem: Qual Ã© a capital do Brasil?
```

### ğŸ‰ Se Funcionou: PARABÃ‰NS!

VocÃª acabou de:
- âœ… Configurar um projeto Spring AI completo
- âœ… Integrar com ChatGPT
- âœ… Criar e testar seu primeiro endpoint de IA

### ğŸ” O Que Aconteceu nos Bastidores?

Vamos dissecar o fluxo:

```
1. Navegador envia: GET /chat?mensagem=OlÃ¡

2. Spring recebe e roteia para ChatController.chat()

3. chatClient.call("OlÃ¡") executa:
   â”œâ”€ Monta requisiÃ§Ã£o HTTP para https://api.openai.com/v1/chat/completions
   â”œâ”€ Inclui header Authorization com sua API key
   â”œâ”€ Envia JSON:
   â”‚  {
   â”‚    "model": "gpt-3.5-turbo",
   â”‚    "messages": [{"role": "user", "content": "OlÃ¡"}],
   â”‚    "temperature": 0.7
   â”‚  }
   â””â”€ Aguarda resposta

4. OpenAI processa e retorna JSON:
   {
     "choices": [
       {"message": {"content": "OlÃ¡! Como posso ajudar?"}}
     ]
   }

5. chatClient extrai o texto da resposta

6. Spring retorna ao navegador
```

### ğŸ§© Melhorando o CÃ³digo: VersÃ£o com Tratamento de Erros

```java
package com.seudominio.docbot.controller;

import org.springframework.ai.chat.ChatClient;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/chat")  // Prefixo /api para organizaÃ§Ã£o
public class ChatController {

    private final ChatClient chatClient;

    public ChatController(ChatClient chatClient) {
        this.chatClient = chatClient;
    }

    /**
     * VersÃ£o melhorada com tratamento de erros
     */
    @GetMapping
    public ResponseEntity<String> chat(
            @RequestParam(required = true) String mensagem) {
        
        try {
            // ValidaÃ§Ã£o bÃ¡sica
            if (mensagem == null || mensagem.trim().isEmpty()) {
                return ResponseEntity
                    .badRequest()
                    .body("Mensagem nÃ£o pode ser vazia");
            }

            // LimitaÃ§Ã£o de tamanho (evitar custos excessivos)
            if (mensagem.length() > 500) {
                return ResponseEntity
                    .badRequest()
                    .body("Mensagem muito longa (mÃ¡ximo 500 caracteres)");
            }

            // Chamada Ã  IA
            String resposta = chatClient.call(mensagem);

            return ResponseEntity.ok(resposta);

        } catch (Exception e) {
            // Log do erro (em produÃ§Ã£o, use um logger apropriado)
            System.err.println("Erro ao processar mensagem: " + e.getMessage());

            return ResponseEntity
                .status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("Erro ao processar sua mensagem. Tente novamente.");
        }
    }
}
```

**Teste os cenÃ¡rios:**

```bash
# Sucesso
curl "http://localhost:8080/api/chat?mensagem=Teste"

# Erro: mensagem vazia
curl "http://localhost:8080/api/chat?mensagem="

# Erro: mensagem muito longa
curl "http://localhost:8080/api/chat?mensagem=$(python3 -c 'print("A"*501)')"
```

---

<a name="2-4"></a>

## ğŸ”§ 2.4 TROUBLESHOOTING DE INSTALAÃ‡ÃƒO

### ğŸ¨ Analogia do TÃ©cnico de TI

Pense nesta seÃ§Ã£o como um manual de primeiros socorros. Problemas acontecem, mas a maioria tem soluÃ§Ã£o rÃ¡pida.

### âŒ Problema 1: "ChatClient could not be found"

**Erro completo:**

```
Field chatClient in ChatController required a bean of type 
'org.springframework.ai.chat.ChatClient' that could not be found.
```

**Causa:** DependÃªncia Spring AI nÃ£o foi incluÃ­da corretamente.

**SoluÃ§Ã£o:**

1. Abra `pom.xml`
2. Verifique se existe:

```xml
<dependency>
    <groupId>org.springframework.ai</groupId>
    <artifactId>spring-ai-openai-spring-boot-starter</artifactId>
</dependency>
```

3. Se nÃ£o existir, adicione dentro de `<dependencies>`
4. Clique direito no projeto â†’ Maven â†’ Reload Project
5. Rebuilde: `mvn clean install`

### âŒ Problema 2: "Invalid API Key"

**Erro:**

```
401 Unauthorized: {"error": {"message": "Incorrect API key provided"}}
```

**Causas possÃ­veis:**

1. **API key incorreta**
   - Copie novamente de https://platform.openai.com/api-keys
   - Verifique se nÃ£o hÃ¡ espaÃ§os extras

2. **VariÃ¡vel de ambiente nÃ£o carregada**

```bash
# Teste:
echo $OPENAI_API_KEY

# Se nÃ£o mostrar nada, a variÃ¡vel nÃ£o estÃ¡ configurada
```

3. **IDE nÃ£o reiniciada apÃ³s configurar variÃ¡vel**
   - Feche completamente a IDE
   - Reabra
   - Execute novamente

**SoluÃ§Ã£o temporÃ¡ria para debug:**

```properties
# application.properties (APENAS PARA TESTES LOCAIS!)
spring.ai.openai.api-key=sk-sua-chave-aqui
```

âš¡ **ATENÃ‡ÃƒO:** Remova isso antes de commitar!

### âŒ Problema 3: Porta 8080 jÃ¡ estÃ¡ em uso

**Erro:**

```
Web server failed to start. Port 8080 was already in use.
```

**SoluÃ§Ã£o 1: Mudar porta**

```properties
# application.properties
server.port=8081
```

**SoluÃ§Ã£o 2: Matar processo na porta 8080**

```bash
# Windows
netstat -ano | findstr :8080
taskkill /PID <nÃºmero_do_pid> /F

# macOS/Linux
lsof -ti:8080 | xargs kill -9
```

### âŒ Problema 4: Timeout ao chamar API

**Erro:**

```
SocketTimeoutException: Read timed out
```

**Causa:** ConexÃ£o lenta ou firewall bloqueando.

**SoluÃ§Ã£o:**

```properties
# application.properties
spring.ai.openai.chat.options.timeout=60s
```

**Testar conectividade:**

```bash
curl https://api.openai.com/v1/models \
  -H "Authorization: Bearer $OPENAI_API_KEY"
```

### âŒ Problema 5: DependÃªncias nÃ£o baixam

**Erro:**

```
Failed to read artifact descriptor for org.springframework.ai:...
```

**SoluÃ§Ã£o:**

1. Limpar cache Maven:

```bash
mvn dependency:purge-local-repository
```

2. ForÃ§ar atualizaÃ§Ã£o:

```bash
mvn clean install -U
```

3. Verificar settings.xml do Maven:

```xml
<!-- ~/.m2/settings.xml -->
<settings>
  <mirrors>
    <mirror>
      <id>central</id>
      <url>https://repo.maven.apache.org/maven2</url>
      <mirrorOf>central</mirrorOf>
    </mirror>
  </mirrors>
</settings>
```

### âŒ Problema 6: Lombok nÃ£o funciona

**Sintoma:** Erros em @Data, @Getter, etc.

**SoluÃ§Ã£o IntelliJ:**

```
1. File â†’ Settings â†’ Plugins
2. Instale "Lombok"
3. File â†’ Settings â†’ Build, Execution, Deployment â†’ Compiler â†’ Annotation Processors
4. Marque "Enable annotation processing"
5. Restart IDE
```

### ğŸ†˜ Checklist de Troubleshooting Geral

Quando algo nÃ£o funcionar, siga esta ordem:

```
1. â˜ Verificar logs completos (nÃ£o apenas Ãºltima linha)
2. â˜ Tentar mvn clean install
3. â˜ Verificar variÃ¡veis de ambiente (echo $NOME_VAR)
4. â˜ Reiniciar IDE completamente
5. â˜ Verificar internet (ping google.com)
6. â˜ Testar com curl diretamente a API
7. â˜ Verificar versÃµes (java -version, mvn -version)
8. â˜ Procurar erro exato no Google/Stack Overflow
9. â˜ Perguntar na comunidade (links no Cap. 15)
```

---

## âš ï¸ ARMADILHAS COMUNS

### âŒ 1. Commitar API Keys no Git

**Problema:**

```bash
git add .
git commit -m "Projeto funcionando"
# ğŸ”¥ Sua chave agora estÃ¡ pÃºblica no GitHub!
```

**SoluÃ§Ã£o:**

Crie `.gitignore`:

```
# Application properties com secrets
application-*.properties
.env

# IDE
.idea/
*.iml

# Build
target/
```

**Se jÃ¡ commitou:**

```bash
# URGENTE: Invalide a chave em https://platform.openai.com/api-keys
# Depois:
git filter-branch --force --index-filter \
  "git rm --cached --ignore-unmatch application.properties" \
  --prune-empty --tag-name-filter cat -- --all
```

### âŒ 2. NÃ£o limitar tamanho de prompts

**Problema:**

```java
// UsuÃ¡rio malicioso pode enviar 100MB de texto
chatClient.call(request.getMensagem());
```

**SoluÃ§Ã£o:**

```java
if (mensagem.length() > 1000) {
    throw new IllegalArgumentException("Mensagem muito longa");
}
```

### âŒ 3. Ignorar custos

**Problema:** NÃ£o monitorar gastos com API.

**SoluÃ§Ã£o:**

```java
@Service
public class CostTracker {
    private AtomicInteger requestCount = new AtomicInteger(0);
    
    public void trackRequest() {
        int count = requestCount.incrementAndGet();
        if (count > 100) { // Limite diÃ¡rio
            throw new RuntimeException("Limite diÃ¡rio atingido");
        }
    }
}
```

---

## ğŸš€ BOAS PRÃTICAS PROFISSIONAIS

### âœ… 1. Profiles do Spring

Separe configuraÃ§Ãµes por ambiente:

**application.properties (base):**

```properties
spring.application.name=docbot-ai
```

**application-dev.properties (desenvolvimento):**

```properties
spring.ai.openai.chat.options.model=gpt-3.5-turbo
logging.level.org.springframework.ai=DEBUG
```

**application-prod.properties (produÃ§Ã£o):**

```properties
spring.ai.openai.chat.options.model=gpt-4
logging.level.org.springframework.ai=INFO
```

**Ativar:**

```bash
# Dev
java -jar app.jar --spring.profiles.active=dev

# Prod
java -jar app.jar --spring.profiles.active=prod
```

### âœ… 2. Health Checks

**Adicione dependÃªncia:**

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```

**Configure:**

```properties
management.endpoints.web.exposure.include=health,info
management.endpoint.health.show-details=always
```

**Teste:**

```bash
curl http://localhost:8080/actuator/health
```

### âœ… 3. Logging Estruturado

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@RestController
public class ChatController {
    private static final Logger log = LoggerFactory.getLogger(ChatController.class);
    
    @GetMapping("/chat")
    public String chat(@RequestParam String mensagem) {
        log.info("Recebida mensagem: {} (tamanho: {})", 
                 mensagem.substring(0, Math.min(50, mensagem.length())),
                 mensagem.length());
        
        try {
            String resposta = chatClient.call(mensagem);
            log.info("Resposta gerada com sucesso (tamanho: {})", resposta.length());
            return resposta;
        } catch (Exception e) {
            log.error("Erro ao processar mensagem", e);
            throw e;
        }
    }
}
```

---

## âœ… CHECKLIST DE DOMÃNIO

- [ ] Instalei e validei JDK 17+
- [ ] Configurei Maven/Gradle funcionando
- [ ] IDE estÃ¡ rodando com plugins Spring
- [ ] Obtive e configurei API key do OpenAI (ou Ollama)
- [ ] Criei projeto Spring AI via Initializr
- [ ] Configurei variÃ¡veis de ambiente de forma segura
- [ ] Executei aplicaÃ§Ã£o sem erros
- [ ] Testei endpoint /chat com sucesso
- [ ] Entendo o fluxo completo de uma requisiÃ§Ã£o
- [ ] Sei resolver os 5 problemas mais comuns

---

## ğŸ”— CONECTANDO OS PONTOS

**O que vimos:**
- Setup completo do ambiente
- Primeiro cÃ³digo funcional
- Troubleshooting essencial

**O que vem a seguir (CapÃ­tulo 3):**
- Anatomia detalhada de uma aplicaÃ§Ã£o Spring AI
- Expandir o chatbot bÃ¡sico
- Adicionar contexto e memÃ³ria

**Projeto DocBot:**
Agora temos a fundaÃ§Ã£o do DocBot. No prÃ³ximo capÃ­tulo, vamos transformÃ¡-lo em um chatbot mais inteligente, capaz de lembrar conversas.

---

## ğŸ“ RESUMO EM BULLETS

- PrÃ©-requisitos: JDK 17+, Maven/Gradle, IDE, API key de LLM
- Setup: Spring Initializr com dependÃªncia `spring-ai-openai-spring-boot-starter`
- SeguranÃ§a: SEMPRE usar variÃ¡veis de ambiente para API keys
- Primeiro cÃ³digo: Controller com ChatClient injetado
- Testes: curl, navegador ou Postman
- Troubleshooting: 90% dos problemas sÃ£o API key ou dependÃªncias
- PrÃ³ximo nÃ­vel: Expandir funcionalidades do chatbot

ğŸ’¡ **DICA PRO:** Salve este capÃ­tulo como referÃªncia para configurar futuros projetos. VocÃª vai reusar esses passos vÃ¡rias vezes.

---

<div style="page-break-after: always;"></div>

<a name="capÃ­tulo-3"></a>

# ğŸ¤– CAPÃTULO 3: HELLO WORLD INTELIGENTE

â±ï¸ **Tempo estimado:** 30 minutos

## ğŸ¯ O QUE VOCÃŠ VAI DOMINAR

Ao final deste capÃ­tulo, vocÃª serÃ¡ capaz de:

- âœ… Compreender a anatomia completa de uma aplicaÃ§Ã£o Spring AI
- âœ… Implementar diferentes tipos de interaÃ§Ãµes com LLMs
- âœ… Personalizar respostas usando parÃ¢metros avanÃ§ados
- âœ… Criar um chatbot com memÃ³ria de conversaÃ§Ã£o
- âœ… Estruturar cÃ³digo seguindo melhores prÃ¡ticas profissionais

## ğŸ§  CONCEITO EM 30 SEGUNDOS

Se o CapÃ­tulo 2 foi montar a cozinha, este Ã© aprender as tÃ©cnicas de cozinha fundamentais. Vamos pegar o cÃ³digo bÃ¡sico e transformÃ¡-lo em algo profissional, explorando todos os ingredientes (componentes) que o Spring AI oferece.

---

<a name="3-1"></a>

## ğŸ—ï¸ 3.1 ANATOMIA DE UMA APLICAÃ‡ÃƒO SPRING AI

### ğŸ¨ Analogia: O Restaurante Completo

Pense em uma aplicaÃ§Ã£o Spring AI como um restaurante:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         ğŸ½ï¸  RESTAURANTE SPRING AI        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                          â”‚
â”‚  ğŸ‘¨â€ğŸ’¼ GarÃ§om (Controller)                  â”‚
â”‚     â†“ "Cliente pediu X"                  â”‚
â”‚                                          â”‚
â”‚  ğŸ‘¨â€ğŸ³ Chef (Service Layer)                 â”‚
â”‚     â†“ "Vou preparar usando IA"           â”‚
â”‚                                          â”‚
â”‚  ğŸ”ª Ferramentas (ChatClient, Prompts)    â”‚
â”‚     â†“ "Ingredientes processados"         â”‚
â”‚                                          â”‚
â”‚  ğŸ“¦ Despensa (Configuration, Models)     â”‚
â”‚     "ConfiguraÃ§Ãµes e recursos"           â”‚
â”‚                                          â”‚
â”‚  ğŸŒ Fornecedor (OpenAI API)              â”‚
â”‚     "MatÃ©ria-prima (respostas)"          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ“ Arquitetura em Camadas

**Estrutura Profissional Completa:**

```
src/main/java/com/seudominio/docbot/
â”‚
â”œâ”€â”€ ğŸ“ controller/          â† Camada de apresentaÃ§Ã£o (REST endpoints)
â”‚   â””â”€â”€ ChatController.java
â”‚
â”œâ”€â”€ ğŸ“ service/             â† LÃ³gica de negÃ³cio
â”‚   â”œâ”€â”€ ChatService.java
â”‚   â””â”€â”€ PromptService.java
â”‚
â”œâ”€â”€ ğŸ“ config/              â† ConfiguraÃ§Ãµes do Spring AI
â”‚   â””â”€â”€ AiConfig.java
â”‚
â”œâ”€â”€ ğŸ“ model/               â† DTOs e entidades
â”‚   â”œâ”€â”€ ChatRequest.java
â”‚   â””â”€â”€ ChatResponse.java
â”‚
â””â”€â”€ ğŸ“ exception/           â† Tratamento de erros
    â””â”€â”€ AiExceptionHandler.java
```

### ğŸ” Componente por Componente

#### 1. Controller - A Interface com o Mundo

```java
package com.seudominio.docbot.controller;

import com.seudominio.docbot.model.ChatRequest;
import com.seudominio.docbot.model.ChatResponse;
import com.seudominio.docbot.service.ChatService;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

/**
 * RESPONSABILIDADE: Receber requisiÃ§Ãµes HTTP e delegar ao Service.
 * 
 * âŒ NÃƒO DEVE: Conter lÃ³gica de negÃ³cio
 * âœ… DEVE: Validar entrada, chamar service, retornar resposta
 */
@RestController
@RequestMapping("/api/v1/chat")  // Versionamento de API (boa prÃ¡tica)
public class ChatController {

    private final ChatService chatService;

    // InjeÃ§Ã£o por construtor (preferÃ­vel a @Autowired em campo)
    public ChatController(ChatService chatService) {
        this.chatService = chatService;
    }

    /**
     * Endpoint para chat simples.
     * 
     * POST /api/v1/chat
     * Body: { "message": "OlÃ¡" }
     * Response: { "response": "OlÃ¡! Como posso ajudar?" }
     */
    @PostMapping
    public ResponseEntity<ChatResponse> chat(@RequestBody ChatRequest request) {
        // Controller apenas delega - nÃ£o processa
        ChatResponse response = chatService.processMessage(request);
        return ResponseEntity.ok(response);
    }
}
```

#### 2. Service - O CÃ©rebro da OperaÃ§Ã£o

```java
package com.seudominio.docbot.service;

import com.seudominio.docbot.model.ChatRequest;
import com.seudominio.docbot.model.ChatResponse;
import org.springframework.ai.chat.ChatClient;
import org.springframework.ai.chat.messages.Message;
import org.springframework.ai.chat.messages.UserMessage;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * RESPONSABILIDADE: Conter a lÃ³gica de negÃ³cio.
 * 
 * âœ… DEVE: Orquestrar chamadas Ã  IA, aplicar regras, processar dados
 */
@Service
public class ChatService {

    private final ChatClient chatClient;

    public ChatService(ChatClient chatClient) {
        this.chatClient = chatClient;
    }

    /**
     * Processa uma mensagem do usuÃ¡rio.
     * 
     * @param request Objeto com a mensagem do usuÃ¡rio
     * @return Resposta estruturada da IA
     */
    public ChatResponse processMessage(ChatRequest request) {
        // 1. ValidaÃ§Ã£o (pode lanÃ§ar exceÃ§Ã£o que serÃ¡ tratada globalmente)
        validateRequest(request);

        // 2. Preparar mensagem para a IA
        Message userMessage = new UserMessage(request.getMessage());
        Prompt prompt = new Prompt(List.of(userMessage));

        // 3. Chamar IA
        String aiResponse = chatClient.call(prompt).getResult().getOutput().getContent();

        // 4. Construir resposta estruturada
        return new ChatResponse(aiResponse, estimateTokens(aiResponse));
    }

    private void validateRequest(ChatRequest request) {
        if (request.getMessage() == null || request.getMessage().isBlank()) {
            throw new IllegalArgumentException("Mensagem nÃ£o pode ser vazia");
        }
        
        if (request.getMessage().length() > 2000) {
            throw new IllegalArgumentException("Mensagem muito longa (mÃ¡x: 2000)");
        }
    }

    private int estimateTokens(String text) {
        // Estimativa grosseira: 1 token â‰ˆ 4 caracteres em inglÃªs
        return text.length() / 4;
    }
}
```

#### 3. Model - Estruturas de Dados

```java
package com.seudominio.docbot.model;

import com.fasterxml.jackson.annotation.JsonProperty;

/**
 * DTO para requisiÃ§Ã£o de chat.
 * 
 * Exemplo JSON:
 * {
 *   "message": "Explique Spring AI",
 *   "context": "Sou iniciante em Java"
 * }
 */
public class ChatRequest {
    
    @JsonProperty("message")  // Mapeia campo JSON para atributo Java
    private String message;
    
    @JsonProperty("context")
    private String context;  // Contexto opcional

    // Construtores
    public ChatRequest() {}
    
    public ChatRequest(String message) {
        this.message = message;
    }

    // Getters e Setters (ou use Lombok @Data)
    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public String getContext() {
        return context;
    }

    public void setContext(String context) {
        this.context = context;
    }
}
```

```java
package com.seudominio.docbot.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import java.time.LocalDateTime;

/**
 * DTO para resposta de chat.
 * 
 * Exemplo JSON:
 * {
 *   "response": "Spring AI Ã©...",
 *   "tokens_used": 150,
 *   "timestamp": "2024-01-15T10:30:00"
 * }
 */
public class ChatResponse {
    
    @JsonProperty("response")
    private String response;
    
    @JsonProperty("tokens_used")
    private int tokensUsed;
    
    @JsonProperty("timestamp")
    private LocalDateTime timestamp;

    // Construtor
    public ChatResponse(String response, int tokensUsed) {
        this.response = response;
        this.tokensUsed = tokensUsed;
        this.timestamp = LocalDateTime.now();
    }

    // Getters (setters opcionais para objetos de resposta)
    public String getResponse() {
        return response;
    }

    public int getTokensUsed() {
        return tokensUsed;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }
}
```

#### 4. Configuration - CustomizaÃ§Ãµes

```java
package com.seudominio.docbot.config;

import org.springframework.ai.chat.ChatClient;
import org.springframework.ai.openai.OpenAiChatClient;
import org.springframework.ai.openai.OpenAiChatOptions;
import org.springframework.ai.openai.api.OpenAiApi;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * RESPONSABILIDADE: Configurar beans customizados do Spring AI.
 * 
 * Aqui vocÃª pode:
 * - Criar clientes customizados
 * - Definir configuraÃ§Ãµes padrÃ£o
 * - Injetar valores de properties
 */
@Configuration
public class AiConfig {

    @Value("${spring.ai.openai.api-key}")
    private String apiKey;

    /**
     * Bean customizado de ChatClient com configuraÃ§Ãµes especÃ­ficas.
     * 
     * Este bean sobrescreve o autoconfiguration padrÃ£o do Spring AI.
     */
    @Bean
    public ChatClient chatClient() {
        // Cria API client da OpenAI
        OpenAiApi openAiApi = new OpenAiApi(apiKey);

        // ConfiguraÃ§Ãµes customizadas
        OpenAiChatOptions options = OpenAiChatOptions.builder()
            .withModel("gpt-3.5-turbo")      // Modelo a usar
            .withTemperature(0.7)             // Criatividade (0-1)
            .withMaxTokens(500)               // Limite de tokens por resposta
            .withTopP(1.0)                    // Nucleus sampling
            .withFrequencyPenalty(0.0)        // Penalidade por repetiÃ§Ã£o
            .withPresencePenalty(0.0)         // Penalidade por presenÃ§a
            .build();

        // Retorna cliente configurado
        return new OpenAiChatClient(openAiApi, options);
    }
}
```

**ExplicaÃ§Ã£o dos ParÃ¢metros:**

| ParÃ¢metro | Range | Efeito | Quando Usar |
|-----------|-------|--------|-------------|
| temperature | 0.0 - 2.0 | Controla aleatoriedade | 0.3 para fatos, 0.9 para criatividade |
| max_tokens | 1 - 4096 | Limite de tamanho da resposta | Controlar custos e tamanho |
| top_p | 0.0 - 1.0 | Nucleus sampling | Geralmente 1.0 (deixe temperature controlar) |
| frequency_penalty | -2.0 - 2.0 | Reduz repetiÃ§Ãµes | 0.5 para evitar texto repetitivo |
| presence_penalty | -2.0 - 2.0 | Incentiva novos tÃ³picos | 0.5 para respostas mais diversas |

#### 5. Exception Handler - Tratamento Global de Erros

```java
package com.seudominio.docbot.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * RESPONSABILIDADE: Capturar exceÃ§Ãµes globalmente e retornar respostas HTTP apropriadas.
 * 
 * âœ… Centraliza tratamento de erros
 * âœ… Retorna mensagens user-friendly
 * âœ… Log de erros para debugging
 */
@RestControllerAdvice  // Aplica a todos os @RestController
public class AiExceptionHandler {

    /**
     * Trata erros de validaÃ§Ã£o (400 Bad Request).
     */
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<Map<String, Object>> handleValidationError(
            IllegalArgumentException ex) {
        
        Map<String, Object> errorResponse = new HashMap<>();
        errorResponse.put("timestamp", LocalDateTime.now());
        errorResponse.put("status", HttpStatus.BAD_REQUEST.value());
        errorResponse.put("error", "Validation Error");
        errorResponse.put("message", ex.getMessage());

        return ResponseEntity
            .status(HttpStatus.BAD_REQUEST)
            .body(errorResponse);
    }

    /**
     * Trata erros internos do servidor (500 Internal Server Error).
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, Object>> handleGenericError(Exception ex) {
        
        // Log do erro (em produÃ§Ã£o, use Logger apropriado)
        System.err.println("Erro nÃ£o tratado: " + ex.getMessage());
        ex.printStackTrace();

        Map<String, Object> errorResponse = new HashMap<>();
        errorResponse.put("timestamp", LocalDateTime.now());
        errorResponse.put("status", HttpStatus.INTERNAL_SERVER_ERROR.value());
        errorResponse.put("error", "Internal Server Error");
        errorResponse.put("message", "Ocorreu um erro ao processar sua solicitaÃ§Ã£o");

        return ResponseEntity
            .status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(errorResponse);
    }
}
```
# ğŸ¤– CAPÃTULO 3: HELLO WORLD INTELIGENTE (ContinuaÃ§Ã£o)

---

<a name="3-2"></a>

## ğŸ’» 3.2 SEU PRIMEIRO CHATBOT EM 15 MINUTOS

### ğŸ¯ Objetivo Deste MÃ³dulo

Construir um chatbot funcional com interface REST que:
- Aceita mensagens do usuÃ¡rio
- Retorna respostas contextualizadas
- Registra histÃ³rico de conversaÃ§Ã£o
- Possui tratamento robusto de erros

### ğŸ¨ Analogia: Montando um LEGO Complexo

Se o capÃ­tulo anterior foi construir peÃ§as individuais de LEGO, agora vamos montÃ¡-las em uma estrutura funcional. Cada peÃ§a tem seu lugar exato.

### ğŸ“ Passo 1: Criar o Modelo de ConversaÃ§Ã£o

**Arquivo:** `src/main/java/com/seudominio/docbot/model/Conversation.java`

```java
package com.seudominio.docbot.model;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

/**
 * Representa uma conversaÃ§Ã£o completa com histÃ³rico de mensagens.
 * 
 * Uma conversaÃ§Ã£o Ã© como uma "sessÃ£o de chat" - mantÃ©m o contexto
 * de todas as mensagens trocadas entre usuÃ¡rio e IA.
 */
public class Conversation {
    
    private final String id;  // ID Ãºnico da conversaÃ§Ã£o
    private final LocalDateTime startedAt;
    private final List<MessagePair> messages;  // HistÃ³rico completo
    
    /**
     * Construtor - inicializa nova conversaÃ§Ã£o
     */
    public Conversation() {
        this.id = UUID.randomUUID().toString();
        this.startedAt = LocalDateTime.now();
        this.messages = new ArrayList<>();
    }
    
    /**
     * Adiciona um par de mensagens (usuÃ¡rio + IA) ao histÃ³rico.
     * 
     * @param userMessage Mensagem enviada pelo usuÃ¡rio
     * @param aiResponse Resposta gerada pela IA
     */
    public void addMessage(String userMessage, String aiResponse) {
        MessagePair pair = new MessagePair(
            userMessage, 
            aiResponse, 
            LocalDateTime.now()
        );
        this.messages.add(pair);
    }
    
    /**
     * Retorna todo o histÃ³rico formatado como contexto para a IA.
     * 
     * Formato:
     * UsuÃ¡rio: OlÃ¡
     * Assistente: OlÃ¡! Como posso ajudar?
     * UsuÃ¡rio: Qual Ã© a capital do Brasil?
     * Assistente: A capital do Brasil Ã© BrasÃ­lia.
     */
    public String getContextHistory() {
        StringBuilder context = new StringBuilder();
        for (MessagePair pair : messages) {
            context.append("UsuÃ¡rio: ").append(pair.getUserMessage()).append("\n");
            context.append("Assistente: ").append(pair.getAiResponse()).append("\n");
        }
        return context.toString();
    }
    
    // Getters
    public String getId() {
        return id;
    }
    
    public LocalDateTime getStartedAt() {
        return startedAt;
    }
    
    public List<MessagePair> getMessages() {
        return new ArrayList<>(messages);  // Retorna cÃ³pia para imutabilidade
    }
    
    public int getMessageCount() {
        return messages.size();
    }
    
    /**
     * Classe interna para representar um par mensagem-resposta.
     */
    public static class MessagePair {
        private final String userMessage;
        private final String aiResponse;
        private final LocalDateTime timestamp;
        
        public MessagePair(String userMessage, String aiResponse, LocalDateTime timestamp) {
            this.userMessage = userMessage;
            this.aiResponse = aiResponse;
            this.timestamp = timestamp;
        }
        
        // Getters
        public String getUserMessage() {
            return userMessage;
        }
        
        public String getAiResponse() {
            return aiResponse;
        }
        
        public LocalDateTime getTimestamp() {
            return timestamp;
        }
    }
}
```

### ğŸ“ Passo 2: Criar o Gerenciador de ConversaÃ§Ãµes

**Arquivo:** `src/main/java/com/seudominio/docbot/service/ConversationManager.java`

```java
package com.seudominio.docbot.service;

import com.seudominio.docbot.model.Conversation;
import org.springframework.stereotype.Service;

import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Gerenciador de conversaÃ§Ãµes ativas.
 * 
 * RESPONSABILIDADE: Armazenar e recuperar conversaÃ§Ãµes por ID.
 * 
 * âš ï¸ NOTA: Esta implementaÃ§Ã£o usa memÃ³ria (nÃ£o persiste apÃ³s restart).
 * Em produÃ§Ã£o, use Redis, banco de dados, etc.
 */
@Service
public class ConversationManager {
    
    // ConcurrentHashMap garante thread-safety
    private final Map<String, Conversation> conversations = new ConcurrentHashMap<>();
    
    /**
     * Cria uma nova conversaÃ§Ã£o.
     * 
     * @return A conversaÃ§Ã£o criada (com ID Ãºnico)
     */
    public Conversation createConversation() {
        Conversation conversation = new Conversation();
        conversations.put(conversation.getId(), conversation);
        return conversation;
    }
    
    /**
     * Busca uma conversaÃ§Ã£o existente por ID.
     * 
     * @param conversationId ID da conversaÃ§Ã£o
     * @return Optional com a conversaÃ§Ã£o (vazio se nÃ£o encontrada)
     */
    public Optional<Conversation> getConversation(String conversationId) {
        return Optional.ofNullable(conversations.get(conversationId));
    }
    
    /**
     * Deleta uma conversaÃ§Ã£o (libera memÃ³ria).
     * 
     * @param conversationId ID da conversaÃ§Ã£o a deletar
     * @return true se deletada, false se nÃ£o existia
     */
    public boolean deleteConversation(String conversationId) {
        return conversations.remove(conversationId) != null;
    }
    
    /**
     * Retorna estatÃ­sticas do gerenciador.
     */
    public Map<String, Object> getStats() {
        return Map.of(
            "active_conversations", conversations.size(),
            "total_messages", conversations.values().stream()
                .mapToInt(Conversation::getMessageCount)
                .sum()
        );
    }
}
```

### ğŸ“ Passo 3: Atualizar o ChatService com Contexto

**Arquivo:** `src/main/java/com/seudominio/docbot/service/ChatService.java` (versÃ£o melhorada)

```java
package com.seudominio.docbot.service;

import com.seudominio.docbot.model.ChatRequest;
import com.seudominio.docbot.model.ChatResponse;
import com.seudominio.docbot.model.Conversation;
import org.springframework.ai.chat.ChatClient;
import org.springframework.ai.chat.messages.Message;
import org.springframework.ai.chat.messages.SystemMessage;
import org.springframework.ai.chat.messages.UserMessage;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;

/**
 * ServiÃ§o de chat com suporte a contexto conversacional.
 */
@Service
public class ChatService {

    private final ChatClient chatClient;
    private final ConversationManager conversationManager;
    
    // Prompt de sistema que define o comportamento da IA
    private static final String SYSTEM_PROMPT = """
        VocÃª Ã© DocBot, um assistente especializado em documentaÃ§Ã£o tÃ©cnica.
        
        CaracterÃ­sticas:
        - Sempre responda em portuguÃªs brasileiro
        - Seja conciso mas completo
        - Use exemplos de cÃ³digo quando apropriado
        - Se nÃ£o souber algo, admita honestamente
        - Mantenha um tom profissional mas amigÃ¡vel
        """;

    public ChatService(ChatClient chatClient, ConversationManager conversationManager) {
        this.chatClient = chatClient;
        this.conversationManager = conversationManager;
    }

    /**
     * Processa mensagem com contexto de conversaÃ§Ã£o.
     * 
     * @param request RequisiÃ§Ã£o com mensagem e ID de conversaÃ§Ã£o (opcional)
     * @return Resposta da IA com metadata
     */
    public ChatResponse processMessage(ChatRequest request) {
        // 1. ValidaÃ§Ã£o
        validateRequest(request);
        
        // 2. Obter ou criar conversaÃ§Ã£o
        Conversation conversation = getOrCreateConversation(request.getConversationId());
        
        // 3. Construir prompt com contexto
        Prompt prompt = buildPromptWithContext(request.getMessage(), conversation);
        
        // 4. Chamar IA
        String aiResponse = chatClient.call(prompt)
            .getResult()
            .getOutput()
            .getContent();
        
        // 5. Atualizar histÃ³rico
        conversation.addMessage(request.getMessage(), aiResponse);
        
        // 6. Construir resposta
        return new ChatResponse(
            aiResponse, 
            estimateTokens(request.getMessage() + aiResponse),
            conversation.getId()
        );
    }

    /**
     * ConstrÃ³i prompt incluindo:
     * - System message (personalidade da IA)
     * - HistÃ³rico de conversaÃ§Ã£o
     * - Mensagem atual do usuÃ¡rio
     */
    private Prompt buildPromptWithContext(String userMessage, Conversation conversation) {
        List<Message> messages = new ArrayList<>();
        
        // 1. System message (sempre primeiro)
        messages.add(new SystemMessage(SYSTEM_PROMPT));
        
        // 2. HistÃ³rico de conversaÃ§Ã£o (se existir)
        String history = conversation.getContextHistory();
        if (!history.isEmpty()) {
            messages.add(new SystemMessage("HistÃ³rico da conversaÃ§Ã£o:\n" + history));
        }
        
        // 3. Mensagem atual do usuÃ¡rio
        messages.add(new UserMessage(userMessage));
        
        return new Prompt(messages);
    }

    /**
     * ObtÃ©m conversaÃ§Ã£o existente ou cria nova.
     */
    private Conversation getOrCreateConversation(String conversationId) {
        if (conversationId != null && !conversationId.isBlank()) {
            return conversationManager.getConversation(conversationId)
                .orElseThrow(() -> new IllegalArgumentException(
                    "ConversaÃ§Ã£o nÃ£o encontrada: " + conversationId
                ));
        }
        return conversationManager.createConversation();
    }

    private void validateRequest(ChatRequest request) {
        if (request.getMessage() == null || request.getMessage().isBlank()) {
            throw new IllegalArgumentException("Mensagem nÃ£o pode ser vazia");
        }
        
        if (request.getMessage().length() > 2000) {
            throw new IllegalArgumentException("Mensagem muito longa (mÃ¡x: 2000 caracteres)");
        }
    }

    private int estimateTokens(String text) {
        // Estimativa: 1 token â‰ˆ 4 caracteres
        return text.length() / 4;
    }
}
```

### ğŸ“ Passo 4: Atualizar os Modelos de Request/Response

**Arquivo:** `src/main/java/com/seudominio/docbot/model/ChatRequest.java` (atualizado)

```java
package com.seudominio.docbot.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

/**
 * Request de chat com suporte a conversaÃ§Ã£o contextual.
 */
public class ChatRequest {
    
    @NotBlank(message = "Mensagem Ã© obrigatÃ³ria")
    @Size(max = 2000, message = "Mensagem muito longa (mÃ¡ximo 2000 caracteres)")
    @JsonProperty("message")
    private String message;
    
    @JsonProperty("conversation_id")
    private String conversationId;  // Opcional - para continuar conversaÃ§Ã£o existente
    
    // Construtores
    public ChatRequest() {}
    
    public ChatRequest(String message) {
        this.message = message;
    }
    
    public ChatRequest(String message, String conversationId) {
        this.message = message;
        this.conversationId = conversationId;
    }

    // Getters e Setters
    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public String getConversationId() {
        return conversationId;
    }

    public void setConversationId(String conversationId) {
        this.conversationId = conversationId;
    }
}
```

**Arquivo:** `src/main/java/com/seudominio/docbot/model/ChatResponse.java` (atualizado)

```java
package com.seudominio.docbot.model;

import com.fasterxml.jackson.annotation.JsonProperty;
import java.time.LocalDateTime;

/**
 * Response de chat com metadata enriquecida.
 */
public class ChatResponse {
    
    @JsonProperty("response")
    private String response;
    
    @JsonProperty("tokens_used")
    private int tokensUsed;
    
    @JsonProperty("timestamp")
    private LocalDateTime timestamp;
    
    @JsonProperty("conversation_id")
    private String conversationId;  // ID para continuar a conversaÃ§Ã£o

    // Construtor
    public ChatResponse(String response, int tokensUsed, String conversationId) {
        this.response = response;
        this.tokensUsed = tokensUsed;
        this.conversationId = conversationId;
        this.timestamp = LocalDateTime.now();
    }

    // Getters
    public String getResponse() {
        return response;
    }

    public int getTokensUsed() {
        return tokensUsed;
    }

    public LocalDateTime getTimestamp() {
        return timestamp;
    }

    public String getConversationId() {
        return conversationId;
    }
}
```

### ğŸ“ Passo 5: Controller Completo com Endpoints Adicionais

**Arquivo:** `src/main/java/com/seudominio/docbot/controller/ChatController.java` (versÃ£o final)

```java
package com.seudominio.docbot.controller;

import com.seudominio.docbot.model.ChatRequest;
import com.seudominio.docbot.model.ChatResponse;
import com.seudominio.docbot.model.Conversation;
import com.seudominio.docbot.service.ChatService;
import com.seudominio.docbot.service.ConversationManager;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

/**
 * API REST para chatbot com gerenciamento de conversaÃ§Ãµes.
 */
@RestController
@RequestMapping("/api/v1/chat")
public class ChatController {

    private final ChatService chatService;
    private final ConversationManager conversationManager;

    public ChatController(ChatService chatService, ConversationManager conversationManager) {
        this.chatService = chatService;
        this.conversationManager = conversationManager;
    }

    /**
     * Endpoint principal de chat.
     * 
     * POST /api/v1/chat
     * 
     * Body:
     * {
     *   "message": "OlÃ¡, como vocÃª estÃ¡?",
     *   "conversation_id": "uuid-opcional"  // Omita para nova conversaÃ§Ã£o
     * }
     * 
     * Response:
     * {
     *   "response": "OlÃ¡! Estou bem, obrigado. Como posso ajudar?",
     *   "tokens_used": 25,
     *   "timestamp": "2024-01-15T10:30:00",
     *   "conversation_id": "123e4567-e89b-12d3-a456-426614174000"
     * }
     */
    @PostMapping
    public ResponseEntity<ChatResponse> chat(@Valid @RequestBody ChatRequest request) {
        ChatResponse response = chatService.processMessage(request);
        return ResponseEntity.ok(response);
    }

    /**
     * Cria uma nova conversaÃ§Ã£o.
     * 
     * POST /api/v1/chat/conversations
     * 
     * Response:
     * {
     *   "conversation_id": "uuid",
     *   "started_at": "2024-01-15T10:30:00",
     *   "message_count": 0
     * }
     */
    @PostMapping("/conversations")
    public ResponseEntity<Map<String, Object>> createConversation() {
        Conversation conversation = conversationManager.createConversation();
        
        return ResponseEntity.ok(Map.of(
            "conversation_id", conversation.getId(),
            "started_at", conversation.getStartedAt(),
            "message_count", conversation.getMessageCount()
        ));
    }

    /**
     * Busca histÃ³rico de uma conversaÃ§Ã£o.
     * 
     * GET /api/v1/chat/conversations/{id}
     */
    @GetMapping("/conversations/{id}")
    public ResponseEntity<Map<String, Object>> getConversation(@PathVariable String id) {
        Conversation conversation = conversationManager.getConversation(id)
            .orElseThrow(() -> new IllegalArgumentException("ConversaÃ§Ã£o nÃ£o encontrada"));
        
        return ResponseEntity.ok(Map.of(
            "conversation_id", conversation.getId(),
            "started_at", conversation.getStartedAt(),
            "message_count", conversation.getMessageCount(),
            "messages", conversation.getMessages()
        ));
    }

    /**
     * Deleta uma conversaÃ§Ã£o.
     * 
     * DELETE /api/v1/chat/conversations/{id}
     */
    @DeleteMapping("/conversations/{id}")
    public ResponseEntity<Void> deleteConversation(@PathVariable String id) {
        boolean deleted = conversationManager.deleteConversation(id);
        
        if (!deleted) {
            return ResponseEntity.notFound().build();
        }
        
        return ResponseEntity.noContent().build();
    }

    /**
     * EstatÃ­sticas do sistema.
     * 
     * GET /api/v1/chat/stats
     */
    @GetMapping("/stats")
    public ResponseEntity<Map<String, Object>> getStats() {
        return ResponseEntity.ok(conversationManager.getStats());
    }
}
```

### ğŸ§ª Passo 6: Testando o Chatbot Completo

#### Teste 1: Nova ConversaÃ§Ã£o

```bash
# Criar nova conversaÃ§Ã£o
curl -X POST http://localhost:8080/api/v1/chat/conversations

# Response:
{
  "conversation_id": "a1b2c3d4-e5f6-7g8h-9i0j-k1l2m3n4o5p6",
  "started_at": "2024-01-15T10:30:00",
  "message_count": 0
}
```

#### Teste 2: Primeira Mensagem

```bash
curl -X POST http://localhost:8080/api/v1/chat \
  -H "Content-Type: application/json" \
  -d '{
    "message": "OlÃ¡! O que Ã© Spring AI?"
  }'

# Response:
{
  "response": "OlÃ¡! Spring AI Ã© um framework que facilita a integraÃ§Ã£o...",
  "tokens_used": 75,
  "timestamp": "2024-01-15T10:31:00",
  "conversation_id": "a1b2c3d4-e5f6-7g8h-9i0j-k1l2m3n4o5p6"
}
```

#### Teste 3: Continuando a ConversaÃ§Ã£o (com Contexto)

```bash
# Use o conversation_id recebido anteriormente
curl -X POST http://localhost:8080/api/v1/chat \
  -H "Content-Type: application/json" \
  -d '{
    "message": "Pode dar um exemplo de cÃ³digo?",
    "conversation_id": "a1b2c3d4-e5f6-7g8h-9i0j-k1l2m3n4o5p6"
  }'

# A IA lembrarÃ¡ que vocÃª perguntou sobre Spring AI!
# Response:
{
  "response": "Claro! Aqui estÃ¡ um exemplo de uso do Spring AI:\n\n```java\n@Service\npublic class ChatService {\n    private final ChatClient chatClient;\n    ...",
  "tokens_used": 120,
  "timestamp": "2024-01-15T10:32:00",
  "conversation_id": "a1b2c3d4-e5f6-7g8h-9i0j-k1l2m3n4o5p6"
}
```

#### Teste 4: Verificar HistÃ³rico

```bash
curl http://localhost:8080/api/v1/chat/conversations/a1b2c3d4-e5f6-7g8h-9i0j-k1l2m3n4o5p6

# Response:
{
  "conversation_id": "a1b2c3d4-e5f6-7g8h-9i0j-k1l2m3n4o5p6",
  "started_at": "2024-01-15T10:30:00",
  "message_count": 2,
  "messages": [
    {
      "userMessage": "OlÃ¡! O que Ã© Spring AI?",
      "aiResponse": "OlÃ¡! Spring AI Ã©...",
      "timestamp": "2024-01-15T10:31:00"
    },
    {
      "userMessage": "Pode dar um exemplo de cÃ³digo?",
      "aiResponse": "Claro! Aqui estÃ¡...",
      "timestamp": "2024-01-15T10:32:00"
    }
  ]
}
```

#### Teste 5: EstatÃ­sticas

```bash
curl http://localhost:8080/api/v1/chat/stats

# Response:
{
  "active_conversations": 3,
  "total_messages": 7
}
```

### ğŸ‰ ParabÃ©ns! VocÃª Construiu um Chatbot Real!

**O que vocÃª acabou de criar:**

âœ… **API REST completa** com mÃºltiplos endpoints
âœ… **Gerenciamento de conversaÃ§Ãµes** com memÃ³ria contextual
âœ… **ValidaÃ§Ã£o de entrada** automÃ¡tica
âœ… **Tratamento de erros** robusto
âœ… **Metadata enriquecida** em respostas
âœ… **CÃ³digo profissional** seguindo melhores prÃ¡ticas

---

<a name="3-3"></a>

## ğŸ” 3.3 ENTENDENDO O QUE ACONTECEU NOS BASTIDORES

### ğŸ¨ Analogia: Raio-X da AplicaÃ§Ã£o

Agora que o chatbot estÃ¡ funcionando, vamos fazer um "raio-X" para entender exatamente o que acontece em cada camada quando vocÃª envia uma mensagem.

### ğŸ“Š Fluxo Completo de Uma RequisiÃ§Ã£o

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    JORNADA DE UMA MENSAGEM                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. Cliente HTTP (Postman/curl)
   â”‚
   â”‚ POST /api/v1/chat
   â”‚ { "message": "OlÃ¡", "conversation_id": "abc123" }
   â”‚
   â–¼
2. Spring DispatcherServlet
   â”‚  â”œâ”€ Identifica o controller (ChatController)
   â”‚  â”œâ”€ Identifica o mÃ©todo (@PostMapping)
   â”‚  â””â”€ Deserializa JSON â†’ ChatRequest object
   â”‚
   â–¼
3. Jakarta Validation
   â”‚  â”œâ”€ Valida @NotBlank
   â”‚  â”œâ”€ Valida @Size(max=2000)
   â”‚  â””â”€ Se falhar â†’ Retorna 400 Bad Request
   â”‚
   â–¼
4. ChatController.chat()
   â”‚  â””â”€ Delega para chatService.processMessage(request)
   â”‚
   â–¼
5. ChatService.processMessage()
   â”‚
   â”œâ”€ 5.1 validateRequest()
   â”‚  â””â”€ Regras de negÃ³cio adicionais
   â”‚
   â”œâ”€ 5.2 getOrCreateConversation()
   â”‚  â”œâ”€ Se conversation_id fornecido:
   â”‚  â”‚  â””â”€ conversationManager.getConversation(id)
   â”‚  â””â”€ SenÃ£o:
   â”‚     â””â”€ conversationManager.createConversation()
   â”‚
   â”œâ”€ 5.3 buildPromptWithContext()
   â”‚  â”œâ”€ Cria SystemMessage (personalidade da IA)
   â”‚  â”œâ”€ Adiciona histÃ³rico (conversation.getContextHistory())
   â”‚  â””â”€ Adiciona UserMessage (mensagem atual)
   â”‚
   â”œâ”€ 5.4 chatClient.call(prompt)
   â”‚  â”‚
   â”‚  â”œâ”€ OpenAiChatClient prepara requisiÃ§Ã£o HTTP
   â”‚  â”‚  â”œâ”€ URL: https://api.openai.com/v1/chat/completions
   â”‚  â”‚  â”œâ”€ Headers:
   â”‚  â”‚  â”‚  â”œâ”€ Authorization: Bearer sk-xxxxx
   â”‚  â”‚  â”‚  â””â”€ Content-Type: application/json
   â”‚  â”‚  â””â”€ Body (JSON):
   â”‚  â”‚     {
   â”‚  â”‚       "model": "gpt-3.5-turbo",
   â”‚  â”‚       "messages": [
   â”‚  â”‚         {"role": "system", "content": "VocÃª Ã© DocBot..."},
   â”‚  â”‚         {"role": "user", "content": "HistÃ³rico..."},
   â”‚  â”‚         {"role": "user", "content": "OlÃ¡"}
   â”‚  â”‚       ],
   â”‚  â”‚       "temperature": 0.7,
   â”‚  â”‚       "max_tokens": 500
   â”‚  â”‚     }
   â”‚  â”‚
   â”‚  â”œâ”€ Envia HTTP POST para OpenAI
   â”‚  â”‚
   â”‚  â”œâ”€ OpenAI processa (pode demorar 1-5 segundos)
   â”‚  â”‚
   â”‚  â”œâ”€ Recebe response JSON:
   â”‚  â”‚  {
   â”‚  â”‚    "id": "chatcmpl-xyz",
   â”‚  â”‚    "choices": [{
   â”‚  â”‚      "message": {
   â”‚  â”‚        "role": "assistant",
   â”‚  â”‚        "content": "OlÃ¡! Como posso ajudar?"
   â”‚  â”‚      },
   â”‚  â”‚      "finish_reason": "stop"
   â”‚  â”‚    }],
   â”‚  â”‚    "usage": {
   â”‚  â”‚      "prompt_tokens": 50,
   â”‚  â”‚      "completion_tokens": 10,
   â”‚  â”‚      "total_tokens": 60
   â”‚  â”‚    }
   â”‚  â”‚  }
   â”‚  â”‚
   â”‚  â””â”€ Extrai content da resposta
   â”‚     â””â”€ Retorna "OlÃ¡! Como posso ajudar?"
   â”‚
   â”œâ”€ 5.5 conversation.addMessage()
   â”‚  â””â”€ Adiciona par (pergunta, resposta) ao histÃ³rico
   â”‚
   â””â”€ 5.6 Cria ChatResponse
      â””â”€ Inclui resposta, tokens, conversationId
   
   â–¼
6. ChatController
   â”‚  â””â”€ Envelopa em ResponseEntity.ok()
   â”‚
   â–¼
7. Spring DispatcherServlet
   â”‚  â”œâ”€ Serializa ChatResponse â†’ JSON
   â”‚  â””â”€ Define headers HTTP (Content-Type: application/json)
   â”‚
   â–¼
8. Cliente HTTP recebe response
   Status: 200 OK
   Body: {"response": "OlÃ¡! Como posso ajudar?", ...}
```

### ğŸ”¬ AnÃ¡lise Profunda: O Que Acontece na Chamada da API OpenAI

#### RequisiÃ§Ã£o HTTP Real Enviada

```http
POST https://api.openai.com/v1/chat/completions HTTP/1.1
Host: api.openai.com
Authorization: Bearer sk-proj-xxxxxxxxxxxxxxxxxxxx
Content-Type: application/json
Content-Length: 456

{
  "model": "gpt-3.5-turbo",
  "messages": [
    {
      "role": "system",
      "content": "VocÃª Ã© DocBot, um assistente especializado em documentaÃ§Ã£o tÃ©cnica.\n\nCaracterÃ­sticas:\n- Sempre responda em portuguÃªs brasileiro\n- Seja conciso mas completo\n- Use exemplos de cÃ³digo quando apropriado\n- Se nÃ£o souber algo, admita honestamente\n- Mantenha um tom profissional mas amigÃ¡vel"
    },
    {
      "role": "system",
      "content": "HistÃ³rico da conversaÃ§Ã£o:\nUsuÃ¡rio: OlÃ¡! O que Ã© Spring AI?\nAssistente: OlÃ¡! Spring AI Ã© um framework...\n"
    },
    {
      "role": "user",
      "content": "Pode dar um exemplo de cÃ³digo?"
    }
  ],
  "temperature": 0.7,
  "max_tokens": 500,
  "top_p": 1.0,
  "frequency_penalty": 0.0,
  "presence_penalty": 0.0
}
```

#### Processamento no Servidor OpenAI

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        DENTRO DO SERVIDOR OPENAI           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                            â”‚
â”‚ 1. Recebe requisiÃ§Ã£o                       â”‚
â”‚    â””â”€ Valida API key                       â”‚
â”‚    â””â”€ Verifica quota/limites               â”‚
â”‚                                            â”‚
â”‚ 2. TokenizaÃ§Ã£o                             â”‚
â”‚    â””â”€ Converte texto em tokens numÃ©ricos  â”‚
â”‚       "Pode" â†’ [47799]                    â”‚
â”‚       "dar" â†’ [29271]                     â”‚
â”‚       "um" â†’ [1234]                       â”‚
â”‚       ...                                  â”‚
â”‚    â””â”€ Total: ~150 tokens (prompt)         â”‚
â”‚                                            â”‚
â”‚ 3. Modelo GPT-3.5-turbo processa          â”‚
â”‚    â”œâ”€ Contexto: system + histÃ³rico        â”‚
â”‚    â”œâ”€ AtenÃ§Ã£o multi-head                  â”‚
â”‚    â”œâ”€ Transformers (12 camadas)           â”‚
â”‚    â””â”€ GeraÃ§Ã£o autoregressiva              â”‚
â”‚       (palavra por palavra)                â”‚
â”‚                                            â”‚
â”‚ 4. Sampling                                â”‚
â”‚    â””â”€ temperature=0.7 adiciona            â”‚
â”‚       aleatoriedade controlada            â”‚
â”‚                                            â”‚
â”‚ 5. DetokenizaÃ§Ã£o                           â”‚
â”‚    â””â”€ Tokens â†’ texto legÃ­vel              â”‚
â”‚                                            â”‚
â”‚ 6. Retorna JSON                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Response HTTP Real Recebida

```http
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 892
x-ratelimit-limit-requests: 3500
x-ratelimit-remaining-requests: 3499
x-ratelimit-limit-tokens: 90000
x-ratelimit-remaining-tokens: 89850

{
  "id": "chatcmpl-8g7xYz123456789",
  "object": "chat.completion",
  "created": 1705320600,
  "model": "gpt-3.5-turbo-0613",
  "choices": [
    {
      "index": 0,
      "message": {
        "role": "assistant",
        "content": "Claro! Aqui estÃ¡ um exemplo bÃ¡sico de uso do Spring AI:\n\n```java\n@Service\npublic class ChatService {\n    private final ChatClient chatClient;\n    \n    public ChatService(ChatClient chatClient) {\n        this.chatClient = chatClient;\n    }\n    \n    public String chat(String mensagem) {\n        return chatClient.call(mensagem);\n    }\n}\n```\n\nEste cÃ³digo cria um serviÃ§o simples que injeta o ChatClient e o usa para enviar mensagens Ã  IA."
      },
      "finish_reason": "stop"
    }
  ],
  "usage": {
    "prompt_tokens": 156,
    "completion_tokens": 94,
    "total_tokens": 250
  }
}
```

### ğŸ’° Anatomia dos Custos

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              CÃLCULO DE CUSTOS (GPT-3.5-turbo)           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                          â”‚
â”‚ Entrada (Prompt): 156 tokens                            â”‚
â”‚ â”œâ”€ System message: 80 tokens                            â”‚
â”‚ â”œâ”€ HistÃ³rico: 60 tokens                                 â”‚
â”‚ â””â”€ Pergunta atual: 16 tokens                            â”‚
â”‚                                                          â”‚
â”‚ SaÃ­da (Completion): 94 tokens                           â”‚
â”‚                                                          â”‚
â”‚ Total: 250 tokens                                        â”‚
â”‚                                                          â”‚
â”‚ PreÃ§o GPT-3.5-turbo (jan/2024):                         â”‚
â”‚ â”œâ”€ Input: $0.0015 / 1K tokens                           â”‚
â”‚ â””â”€ Output: $0.002 / 1K tokens                           â”‚
â”‚                                                          â”‚
â”‚ Custo desta requisiÃ§Ã£o:                                 â”‚
â”‚ â”œâ”€ Input: 156 Ã— 0.0015 / 1000 = $0.000234              â”‚
â”‚ â”œâ”€ Output: 94 Ã— 0.002 / 1000 = $0.000188               â”‚
â”‚ â””â”€ TOTAL: $0.000422 (~R$ 0.002 centavos)               â”‚
â”‚                                                          â”‚
â”‚ âš ï¸ Com histÃ³rico de 10 mensagens:                       â”‚
â”‚    Cada nova pergunta custarÃ¡ ~3x mais                  â”‚
â”‚    (devido ao contexto acumulado)                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ğŸ§  DecisÃµes de Design Importantes

#### Por Que Usar SystemMessage?

```java
// âŒ SEM SystemMessage:
messages.add(new UserMessage("VocÃª Ã© um assistente. Responda: " + pergunta));
// Problema: UsuÃ¡rio pode sobrescrever personalidade

// âœ… COM SystemMessage:
messages.add(new SystemMessage("VocÃª Ã© DocBot..."));
messages.add(new UserMessage(pergunta));
// Vantagem: Personalidade protegida, nÃ£o conta para histÃ³rico do usuÃ¡rio
```

#### Por Que ConcurrentHashMap para ConversaÃ§Ãµes?

```java
// âŒ HashMap normal:
private final Map<String, Conversation> conversations = new HashMap<>();
// Problema: NÃ£o Ã© thread-safe. MÃºltiplos usuÃ¡rios simultÃ¢neos = DESASTRE

// âœ… ConcurrentHashMap:
private final Map<String, Conversation> conversations = new ConcurrentHashMap<>();
// Vantagem: Thread-safe, perfeito para ambientes multi-thread (web)
```

#### Por Que Validar DUAS Vezes?

```java
// ValidaÃ§Ã£o 1: Jakarta Validation (automÃ¡tica)
@NotBlank(message = "Mensagem Ã© obrigatÃ³ria")
private String message;

// ValidaÃ§Ã£o 2: No Service (manual)
if (request.getMessage().length() > 2000) {
    throw new IllegalArgumentException("Mensagem muito longa");
}
```

**Motivo:**
- **ValidaÃ§Ã£o 1:** Garante formato bÃ¡sico (nÃ£o nulo, nÃ£o vazio)
- **ValidaÃ§Ã£o 2:** Regras de negÃ³cio complexas (limites de custo, contexto especÃ­fico)

### ğŸ­ CenÃ¡rios de Fluxo Especiais

#### CenÃ¡rio 1: Erro de Rede com OpenAI

```
Usuario envia mensagem
    â†“
ChatService.processMessage()
    â†“
chatClient.call(prompt)
    â†“
HTTP POST para OpenAI
    â†“
âŒ Timeout (30 segundos)
    â†“
Spring AI lanÃ§a ResourceAccessException
    â†“
AiExceptionHandler.handleGenericError()
    â†“
Response 500 para usuÃ¡rio:
{
  "error": "Internal Server Error",
  "message": "Erro ao processar sua mensagem. Tente novamente."
}
```

#### CenÃ¡rio 2: ConversaÃ§Ã£o NÃ£o Encontrada

```
Usuario envia mensagem com conversation_id inexistente
    â†“
ChatService.getOrCreateConversation()
    â†“
conversationManager.getConversation(id)
    â†“
Returns Optional.empty()
    â†“
.orElseThrow(() -> new IllegalArgumentException(...))
    â†“
AiExceptionHandler.handleValidationError()
    â†“
Response 400 para usuÃ¡rio:
{
  "error": "Validation Error",
  "message": "ConversaÃ§Ã£o nÃ£o encontrada: abc123"
}
```

### ğŸ” SeguranÃ§a: O Que Protege Sua API Key

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          CAMADAS DE PROTEÃ‡ÃƒO DA API KEY            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                    â”‚
â”‚ 1. VariÃ¡vel de Ambiente                           â”‚
â”‚    â”œâ”€ Nunca no cÃ³digo-fonte                       â”‚
â”‚    â””â”€ NÃ£o commitada no Git                        â”‚
â”‚                                                    â”‚
â”‚ 2. application.properties                         â”‚
â”‚    â”œâ”€ ${OPENAI_API_KEY} placeholder               â”‚
â”‚    â””â”€ Resolvido em runtime                        â”‚
â”‚                                                    â”‚
â”‚ 3. Spring @Value injection                        â”‚
â”‚    â”œâ”€ Injetada no AiConfig                        â”‚
â”‚    â””â”€ NÃ£o exposta em logs                         â”‚
â”‚                                                    â”‚
â”‚ 4. OpenAiApi (classe interna Spring AI)          â”‚
â”‚    â”œâ”€ Armazena key em campo privado              â”‚
â”‚    â””â”€ Apenas usa em headers HTTP                  â”‚
â”‚                                                    â”‚
â”‚ 5. HTTPS                                           â”‚
â”‚    â””â”€ ComunicaÃ§Ã£o criptografada com OpenAI       â”‚
â”‚                                                    â”‚
â”‚ âš ï¸ NUNCA FAÃ‡A:                                    â”‚
â”‚    String apiKey = "sk-xxxxx";  // âŒ PERIGO!    â”‚
â”‚    System.out.println(apiKey);  // âŒ NUNCA!     â”‚
â”‚    logger.info("Key: " + key);  // âŒ NÃƒO!       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

<a name="3-4"></a>

## ğŸš€ 3.4 EXPANDINDO O EXEMPLO BÃSICO

### ğŸ¯ Objetivo

Adicionar funcionalidades profissionais que transformam nosso chatbot de "demo" para "production-ready":

1. **Streaming de Respostas** (respostas em tempo real)
2. **Rate Limiting** (proteÃ§Ã£o contra abuso)
3. **MÃ©tricas e Monitoramento**
4. **Cache Inteligente**
5. **MÃºltiplos Modelos** (fallback strategy)

---

### ğŸ“¡ FEATURE 1: Streaming de Respostas

#### ğŸ¨ Analogia

**Sem streaming:** Ã‰ como esperar um arquivo de 1GB baixar 100% para depois abrir.

**Com streaming:** Ã‰ como Netflix - comeÃ§a a assistir enquanto ainda estÃ¡ baixando.

#### ğŸ’» ImplementaÃ§Ã£o

**1. Criar DTO para Streaming**

`src/main/java/com/seudominio/docbot/model/StreamChunk.java`

```java
package com.seudominio.docbot.model;

import com.fasterxml.jackson.annotation.JsonProperty;

/**
 * Representa um "pedaÃ§o" de resposta em streaming.
 */
public class StreamChunk {
    
    @JsonProperty("content")
    private String content;  // Parte do texto
    
    @JsonProperty("is_final")
    private boolean isFinal;  // true se for o Ãºltimo chunk
    
    @JsonProperty("conversation_id")
    private String conversationId;
    
    public StreamChunk(String content, boolean isFinal, String conversationId) {
        this.content = content;
        this.isFinal = isFinal;
        this.conversationId = conversationId;
    }
    
    // Getters
    public String getContent() { return content; }
    public boolean isFinal() { return isFinal; }
    public String getConversationId() { return conversationId; }
}
```

**2. Service com Suporte a Streaming**

`ChatService.java` (adicionar mÃ©todo)

```java
import org.springframework.ai.chat.StreamingChatClient;
import reactor.core.publisher.Flux;

@Service
public class ChatService {
    
    private final ChatClient chatClient;
    private final StreamingChatClient streamingChatClient;  // NOVO
    private final ConversationManager conversationManager;
    
    // Construtor atualizado
    public ChatService(
            ChatClient chatClient, 
            StreamingChatClient streamingChatClient,
            ConversationManager conversationManager) {
        this.chatClient = chatClient;
        this.streamingChatClient = streamingChatClient;
        this.conversationManager = conversationManager;
    }
    
    // MÃ©todo existente: processMessage()...
    
    /**
     * NOVO: Processa mensagem com streaming (retorna Flux reativo).
     * 
     * @param request RequisiÃ§Ã£o de chat
     * @return Flux de chunks de texto (enviados conforme gerados)
     */
    public Flux<StreamChunk> processMessageStreaming(ChatRequest request) {
        validateRequest(request);
        
        Conversation conversation = getOrCreateConversation(request.getConversationId());
        Prompt prompt = buildPromptWithContext(request.getMessage(), conversation);
        
        // StringBuilder para acumular resposta completa
        StringBuilder fullResponse = new StringBuilder();
        
        return streamingChatClient.stream(prompt)
            .map(chatResponse -> {
                // Extrai conteÃºdo de cada chunk
                String content = chatResponse.getResult().getOutput().getContent();
                fullResponse.append(content);
                
                return new StreamChunk(
                    content, 
                    false,  // NÃ£o Ã© final ainda
                    conversation.getId()
                );
            })
            .concatWith(Flux.defer(() -> {
                // ApÃ³s todos os chunks, adiciona ao histÃ³rico
                conversation.addMessage(request.getMessage(), fullResponse.toString());
                
                // Envia chunk final (vazio, apenas sinaliza fim)
                return Flux.just(new StreamChunk(
                    "", 
                    true,  // Ã‰ o chunk final
                    conversation.getId()
                ));
            }));
    }
}
```

**3. Controller com Endpoint de Streaming**

`ChatController.java` (adicionar mÃ©todo)

```java
import org.springframework.http.MediaType;
import reactor.core.publisher.Flux;

@RestController
@RequestMapping("/api/v1/chat")
public class ChatController {
    
    // Campos e mÃ©todos existentes...
    
    /**
     * NOVO: Endpoint de streaming.
     * 
     * POST /api/v1/chat/stream
     * 
     * Retorna Server-Sent Events (text/event-stream).
     * Cliente recebe chunks conforme gerados.
     */
    @PostMapping(
        value = "/stream",
        produces = MediaType.TEXT_EVENT_STREAM_VALUE
    )
    public Flux<StreamChunk> chatStream(@Valid @RequestBody ChatRequest request) {
        return chatService.processMessageStreaming(request);
    }
}
```

**4. Testando Streaming**

```bash
# Com curl (mostra chunks conforme chegam)
curl -N -X POST http://localhost:8080/api/v1/chat/stream \
  -H "Content-Type: application/json" \
  -d '{"message":"Escreva um poema sobre Spring AI"}' 

# Output (em tempo real):
data:{"content":"Primavera","is_final":false,"conversation_id":"..."}

data:{"content":" do","is_final":false,"conversation_id":"..."}

data:{"content":" cÃ³digo","is_final":false,"conversation_id":"..."}

data:{"content":",","is_final":false,"conversation_id":"..."}
...
data:{"content":"","is_final":true,"conversation_id":"..."}
```

**Cliente JavaScript para Streaming:**

```javascript
const eventSource = new EventSource('/api/v1/chat/stream');

eventSource.onmessage = (event) => {
    const chunk = JSON.parse(event.data);
    
    if (chunk.is_final) {
        console.log('Streaming concluÃ­do!');
        eventSource.close();
    } else {
        // Adiciona chunk ao DOM
        document.getElementById('chat').innerHTML += chunk.content;
    }
};
```

---

### ğŸ›¡ï¸ FEATURE 2: Rate Limiting (ProteÃ§Ã£o Contra Abuso)

#### ğŸ¨ Analogia

Rate limiting Ã© como um seguranÃ§a de boate: permite X pessoas por hora. Se exceder, vocÃª espera na fila.

#### ğŸ’» ImplementaÃ§Ã£o

**1. Adicionar DependÃªncia**

`pom.xml`

```xml
<dependency>
    <groupId>com.github.vladimir-bukhtoyarov</groupId>
    <artifactId>bucket4j-core</artifactId>
    <version>8.7.0</version>
</dependency>
```

**2. Configurar Rate Limiter**

`src/main/java/com/seudominio/docbot/config/RateLimitConfig.java`

```java
package com.seudominio.docbot.config;

import io.github.bucket4j.Bandwidth;
import io.github.bucket4j.Bucket;
import io.github.bucket4j.Refill;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.Duration;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * ConfiguraÃ§Ã£o de rate limiting.
 * 
 * Limite: 10 requisiÃ§Ãµes por minuto por IP.
 */
@Configuration
public class RateLimitConfig {
    
    private final Map<String, Bucket> buckets = new ConcurrentHashMap<>();
    
    /**
     * Cria ou retorna bucket para um IP.
     */
    public Bucket resolveBucket(String ip) {
        return buckets.computeIfAbsent(ip, k -> createNewBucket());
    }
    
    private Bucket createNewBucket() {
        // Capacidade: 10 tokens
        // Refill: 10 tokens a cada 1 minuto
        Bandwidth limit = Bandwidth.classic(
            10, 
            Refill.intervally(10, Duration.ofMinutes(1))
        );
        
        return Bucket.builder()
            .addLimit(limit)
            .build();
    }
}
```

**3. Interceptor para Rate Limiting**

`src/main/java/com/seudominio/docbot/interceptor/RateLimitInterceptor.java`

```java
package com.seudominio.docbot.interceptor;

import com.seudominio.docbot.config.RateLimitConfig;
import io.github.bucket4j.Bucket;
import io.github.bucket4j.ConsumptionProbe;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.HandlerInterceptor;

/**
 * Interceptor que aplica rate limiting em todas as requisiÃ§Ãµes.
 */
@Component
public class RateLimitInterceptor implements HandlerInterceptor {
    
    private final RateLimitConfig rateLimitConfig;
    
    public RateLimitInterceptor(RateLimitConfig rateLimitConfig) {
        this.rateLimitConfig = rateLimitConfig;
    }
    
    @Override
    public boolean preHandle(
            HttpServletRequest request, 
            HttpServletResponse response, 
            Object handler) throws Exception {
        
        String ip = getClientIP(request);
        Bucket bucket = rateLimitConfig.resolveBucket(ip);
        
        // Tenta consumir 1 token
        ConsumptionProbe probe = bucket.tryConsumeAndReturnRemaining(1);
        
        if (probe.isConsumed()) {
            // Adiciona headers informativos
            response.addHeader("X-Rate-Limit-Remaining", 
                String.valueOf(probe.getRemainingTokens()));
            return true;  // Permite requisiÃ§Ã£o
        } else {
            // Limite excedido
            long waitForRefill = probe.getNanosToWaitForRefill() / 1_000_000_000;
            
            response.setStatus(429);  // Too Many Requests
            response.addHeader("X-Rate-Limit-Retry-After-Seconds", 
                String.valueOf(waitForRefill));
            response.getWriter().write(
                "{\"error\":\"Rate limit exceeded. Retry in " + waitForRefill + " seconds\"}"
            );
            
            return false;  // Bloqueia requisiÃ§Ã£o
        }
    }
    
    private String getClientIP(HttpServletRequest request) {
        String xfHeader = request.getHeader("X-Forwarded-For");
        if (xfHeader == null) {
            return request.getRemoteAddr();
        }
        return xfHeader.split(",")[0];
    }
}
```

**4. Registrar Interceptor**

`src/main/java/com/seudominio/docbot/config/WebConfig.java`

```java
package com.seudominio.docbot.config;

import com.seudominio.docbot.interceptor.RateLimitInterceptor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {
    
    private final RateLimitInterceptor rateLimitInterceptor;
    
    public WebConfig(RateLimitInterceptor rateLimitInterceptor) {
        this.rateLimitInterceptor = rateLimitInterceptor;
    }
    
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(rateLimitInterceptor)
                .addPathPatterns("/api/**");  // Aplica em todos os endpoints /api
    }
}
```

**5. Testando Rate Limiting**

```bash
# FaÃ§a 11 requisiÃ§Ãµes rÃ¡pidas
for i in {1..11}; do
  curl -X POST http://localhost:8080/api/v1/chat \
    -H "Content-Type: application/json" \
    -d '{"message":"teste"}' \
    -w "\nStatus: %{http_code}\n"
done

# Primeiras 10: Status 200
# 11Âª requisiÃ§Ã£o: Status 429
# Response:
# {"error":"Rate limit exceeded. Retry in 60 seconds"}
```

---

### ğŸ“Š FEATURE 3: MÃ©tricas e Monitoramento

#### ğŸ’» ImplementaÃ§Ã£o

**1. Adicionar DependÃªncia Micrometer**

`pom.xml`

```xml
<dependency>
    <groupId>io.micrometer</groupId>
    <artifactId>micrometer-registry-prometheus</artifactId>
</dependency>
```

**2. Habilitar Endpoints Actuator**

`application.properties`

```properties
management.endpoints.web.exposure.include=health,info,prometheus,metrics
management.metrics.export.prometheus.enabled=true
```

**3. Service com MÃ©tricas**

`ChatService.java` (atualizar)

```java
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;

@Service
public class ChatService {
    
    private final ChatClient chatClient;
    private final ConversationManager conversationManager;
    private final MeterRegistry meterRegistry;  // NOVO
    
    public ChatService(
            ChatClient chatClient,
            ConversationManager conversationManager,
            MeterRegistry meterRegistry) {
        this.chatClient = chatClient;
        this.conversationManager = conversationManager;
        this.meterRegistry = meterRegistry;
    }
    
    public ChatResponse processMessage(ChatRequest request) {
        // Inicia timer
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            validateRequest(request);
            Conversation conversation = getOrCreateConversation(request.getConversationId());
            Prompt prompt = buildPromptWithContext(request.getMessage(), conversation);
            
            String aiResponse = chatClient.call(prompt)
                .getResult()
                .getOutput()
                .getContent();
            
            conversation.addMessage(request.getMessage(), aiResponse);
            
            // Incrementa contador de sucesso
            meterRegistry.counter("docbot.chat.requests", 
                "status", "success").increment();
            
            // Registra tokens usados
            int tokens = estimateTokens(request.getMessage() + aiResponse);
            meterRegistry.counter("docbot.chat.tokens.used").increment(tokens);
            
            return new ChatResponse(aiResponse, tokens, conversation.getId());
            
        } catch (Exception e) {
            // Incrementa contador de erro
            meterRegistry.counter("docbot.chat.requests", 
                "status", "error").increment();
            throw e;
            
        } finally {
            // Para timer e registra duraÃ§Ã£o
            sample.stop(meterRegistry.timer("docbot.chat.duration"));
        }
    }
    
    // Outros mÃ©todos...
}
```

**4. Acessar MÃ©tricas**

```bash
# Formato Prometheus
curl http://localhost:8080/actuator/prometheus

# Output:
# docbot_chat_requests_total{status="success",} 127.0
# docbot_chat_requests_total{status="error",} 3.0
# docbot_chat_tokens_used_total 45890.0
# docbot_chat_duration_seconds_sum 234.5
# docbot_chat_duration_seconds_max 5.2
```

**5. Dashboard Grafana (Query Exemplo)**

```promql
# Taxa de requisiÃ§Ãµes por segundo
rate(docbot_chat_requests_total[1m])

# DuraÃ§Ã£o mÃ©dia das requisiÃ§Ãµes
rate(docbot_chat_duration_seconds_sum[5m]) 
/ 
rate(docbot_chat_duration_seconds_count[5m])

# Tokens usados por hora
increase(docbot_chat_tokens_used_total[1h])
```

---

### ğŸ’¾ FEATURE 4: Cache Inteligente

#### ğŸ¨ Analogia

Cache Ã© como ter um "caderno de cola" com respostas frequentes. Se a pergunta Ã© igual, nÃ£o precisa "pensar" de novo - sÃ³ copia a resposta anterior.

#### ğŸ’» ImplementaÃ§Ã£o

**1. Adicionar DependÃªncia**

`pom.xml`

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>

<dependency>
    <groupId>com.github.ben-manes.caffeine</groupId>
    <artifactId>caffeine</artifactId>
</dependency>
```

**2. Configurar Cache**

`src/main/java/com/seudominio/docbot/config/CacheConfig.java`

```java
package com.seudominio.docbot.config;

import com.github.benmanes.caffeine.cache.Caffeine;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.caffeine.CaffeineCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.TimeUnit;

@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager("chatResponses");
        
        cacheManager.setCaffeine(Caffeine.newBuilder()
            .maximumSize(1000)  // MÃ¡ximo 1000 entradas
            .expireAfterWrite(1, TimeUnit.HOURS)  // Expira apÃ³s 1 hora
            .recordStats());  // Habilita estatÃ­sticas
        
        return cacheManager;
    }
}
```

**3. Service com Cache**

`ChatService.java` (adicionar mÃ©todo)

```java
import org.springframework.cache.annotation.Cacheable;

@Service
public class ChatService {
    
    // MÃ©todos existentes...
    
    /**
     * NOVO: MÃ©todo com cache para perguntas simples (sem contexto).
     * 
     * Se a mesma pergunta for feita, retorna resposta cacheada
     * (economiza chamada Ã  API e reduz latÃªncia).
     */
    @Cacheable(value = "chatResponses", key = "#message")
    public String chatSimpleWithCache(String message) {
        validateSimpleMessage(message);
        
        // Esta chamada sÃ³ acontece se nÃ£o estiver em cache
        return chatClient.call(message);
    }
    
    private void validateSimpleMessage(String message) {
        if (message == null || message.isBlank()) {
            throw new IllegalArgumentException("Mensagem nÃ£o pode ser vazia");
        }
    }
}
```

**4. Controller com Endpoint Cacheado**

`ChatController.java` (adicionar)

```java
/**
 * NOVO: Endpoint simples com cache.
 * 
 * GET /api/v1/chat/simple?message=OlÃ¡
 * 
 * Ideal para FAQs que nÃ£o precisam de contexto.
 */
@GetMapping("/simple")
public ResponseEntity<String> chatSimple(@RequestParam String message) {
    String response = chatService.chatSimpleWithCache(message);
    return ResponseEntity.ok(response);
}
```

**5. Testando Cache**

```bash
# Primeira chamada (vai Ã  API OpenAI - ~2 segundos)
time curl "http://localhost:8080/api/v1/chat/simple?message=Qual%20a%20capital%20do%20Brasil"
# Response: "A capital do Brasil Ã© BrasÃ­lia."
# real  0m2.134s

# Segunda chamada (resposta do cache - ~10ms)
time curl "http://localhost:8080/api/v1/chat/simple?message=Qual%20a%20capital%20do%20Brasil"
# Response: "A capital do Brasil Ã© BrasÃ­lia." (mesma resposta)
# real  0m0.012s  â† 200x mais rÃ¡pido!
```

**6. MÃ©tricas de Cache**

```bash
curl http://localhost:8080/actuator/metrics/cache.gets

# Output:
{
  "name": "cache.gets",
  "measurements": [
    {"statistic": "HIT", "value": 45.0},
    {"statistic": "MISS", "value": 12.0}
  ]
}

# Hit Rate: 45 / (45 + 12) = 78.9%
```

---

### ğŸ”„ FEATURE 5: MÃºltiplos Modelos (Fallback Strategy)

#### ğŸ¨ Analogia

Ã‰ como ter 3 chefs na cozinha: se o chef principal estÃ¡ ocupado, o segundo assume. Se ambos estÃ£o indisponÃ­veis, o terceiro entra em aÃ§Ã£o.

#### ğŸ’» ImplementaÃ§Ã£o

**1. Configurar MÃºltiplos Clientes**

`AiConfig.java` (expandir)

```java
package com.seudominio.docbot.config;

import org.springframework.ai.chat.ChatClient;
import org.springframework.ai.openai.OpenAiChatClient;
import org.springframework.ai.anthropic.AnthropicChatClient;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

@Configuration
public class AiConfig {
    
    @Value("${spring.ai.openai.api-key}")
    private String openaiKey;
    
    @Value("${spring.ai.anthropic.api-key}")
    private String anthropicKey;
    
    /**
     * Cliente primÃ¡rio: OpenAI GPT-3.5-turbo
     */
    @Bean
    @Primary
    public ChatClient primaryChatClient() {
        // ConfiguraÃ§Ã£o OpenAI...
        return new OpenAiChatClient(/* ... */);
    }
    
    /**
     * Cliente fallback: Anthropic Claude
     */
    @Bean("fallbackChatClient")
    public ChatClient fallbackChatClient() {
        // ConfiguraÃ§Ã£o Anthropic...
        return new AnthropicChatClient(/* ... */);
    }
}
```

**2. Service com Fallback**

`src/main/java/com/seudominio/docbot/service/ResilientChatService.java`

```java
package com.seudominio.docbot.service;

import org.springframework.ai.chat.ChatClient;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Service com estratÃ©gia de fallback entre modelos.
 */
@Service
public class ResilientChatService {
    
    private static final Logger log = LoggerFactory.getLogger(ResilientChatService.class);
    
    private final ChatClient primaryClient;
    private final ChatClient fallbackClient;
    
    public ResilientChatService(
            ChatClient primaryClient,
            @Qualifier("fallbackChatClient") ChatClient fallbackClient) {
        this.primaryClient = primaryClient;
        this.fallbackClient = fallbackClient;
    }
    
    /**
     * Tenta primary, se falhar usa fallback.
     */
    public String chat(String message) {
        try {
            log.info("Tentando primary client (OpenAI)...");
            return primaryClient.call(message);
            
        } catch (Exception e) {
            log.warn("Primary client falhou: {}. Usando fallback...", e.getMessage());
            
            try {
                return fallbackClient.call(message);
            } catch (Exception fallbackError) {
                log.error("Fallback tambÃ©m falhou!", fallbackError);
                throw new RuntimeException("Todos os modelos estÃ£o indisponÃ­veis");
            }
        }
    }
}
```

**3. Testando Fallback**

```bash
# Simular falha da OpenAI (API key invÃ¡lida temporariamente)
curl -X POST http://localhost:8080/api/v1/chat/resilient \
  -H "Content-Type: application/json" \
  -d '{"message":"Teste de fallback"}'

# Logs:
# INFO  - Tentando primary client (OpenAI)...
# WARN  - Primary client falhou: 401 Unauthorized. Usando fallback...
# INFO  - Fallback (Anthropic) processou com sucesso

# Response (vem do Claude):
{
  "response": "Teste de fallback bem-sucedido!",
  "model_used": "claude-2"
}
```

---

## âš ï¸ ARMADILHAS COMUNS

### âŒ 1. NÃ£o Limitar HistÃ³rico de ConversaÃ§Ã£o

**Problema:**

```java
// ConversaÃ§Ã£o com 100 mensagens
// Prompt final: 10.000 tokens
// Custo: $0.15 POR MENSAGEM! ğŸ’¸
```

**SoluÃ§Ã£o:**

```java
public String getContextHistory() {
    // Limita aos Ãºltimos 10 pares de mensagens
    int start = Math.max(0, messages.size() - 10);
    List<MessagePair> recentMessages = messages.subList(start, messages.size());
    
    StringBuilder context = new StringBuilder();
    for (MessagePair pair : recentMessages) {
        context.append("UsuÃ¡rio: ").append(pair.getUserMessage()).append("\n");
        context.append("Assistente: ").append(pair.getAiResponse()).append("\n");
    }
    return context.toString();
}
```

### âŒ 2. NÃ£o Tratar Timeouts

**Problema:**

```java
// UsuÃ¡rio espera 60 segundos, nada acontece
String response = chatClient.call(prompt);  // Timeout sem tratamento
```

**SoluÃ§Ã£o:**

```java
@Bean
public ChatClient chatClient() {
    // ...
    RestTemplate restTemplate = new RestTemplate();
    restTemplate.setRequestFactory(new HttpComponentsClientHttpRequestFactory() {{
        setConnectTimeout(10_000);  // 10 segundos
        setReadTimeout(30_000);     // 30 segundos
    }});
    // ...
}
```

### âŒ 3. Expor InformaÃ§Ãµes SensÃ­veis em Logs

**Problema:**

```java
log.info("Processando mensagem: {}", request.getMessage());
// UsuÃ¡rio enviou: "Meu CPF Ã© 123.456.789-00"
// Agora estÃ¡ no log! ğŸš¨
```

**SoluÃ§Ã£o:**

```java
log.info("Processando mensagem (tamanho: {})", request.getMessage().length());
// Log seguro, nÃ£o expÃµe conteÃºdo
```

---

## ğŸš€ BOAS PRÃTICAS PROFISSIONAIS

### âœ… 1. Versionamento de API

```java
@RestController
@RequestMapping("/api/v1/chat")  // v1 explÃ­cito
public class ChatController {
    // Quando mudar breaking changes, crie v2
}

// Futuro: /api/v2/chat com mudanÃ§as incompatÃ­veis
```

### âœ… 2. Health Checks Customizados

```java
package com.seudominio.docbot.health;

import org.springframework.ai.chat.ChatClient;
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Component;

@Component
public class AiHealthIndicator implements HealthIndicator {
    
    private final ChatClient chatClient;
    
    public AiHealthIndicator(ChatClient chatClient) {
        this.chatClient = chatClient;
    }
    
    @Override
    public Health health() {
        try {
            // Testa com prompt simples
            chatClient.call("ping");
            return Health.up()
                .withDetail("model", "gpt-3.5-turbo")
                .withDetail("status", "operational")
                .build();
        } catch (Exception e) {
            return Health.down()
                .withDetail("error", e.getMessage())
                .build();
        }
    }
}
```

```bash
curl http://localhost:8080/actuator/health

# Response:
{
  "status": "UP",
  "components": {
    "ai": {
      "status": "UP",
      "details": {
        "model": "gpt-3.5-turbo",
        "status": "operational"
      }
    }
  }
}
```

### âœ… 3. DocumentaÃ§Ã£o com OpenAPI/Swagger

`pom.xml`

```xml
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>2.3.0</version>
</dependency>
```

`ChatController.java` (adicionar anotaÃ§Ãµes)

```java
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;

@RestController
@RequestMapping("/api/v1/chat")
@Tag(name = "Chat", description = "API de conversaÃ§Ã£o com IA")
public class ChatController {
    
    @PostMapping
    @Operation(
        summary = "Envia mensagem para o chatbot",
        description = "Processa mensagem do usuÃ¡rio e retorna resposta da IA"
    )
    public ResponseEntity<ChatResponse> chat(@Valid @RequestBody ChatRequest request) {
        // ...
    }
}
```

Acesse: http://localhost:8080/swagger-ui.html

---

## âœ… CHECKLIST DE DOMÃNIO DO CAPÃTULO 3

- [ ] Compreendo a arquitetura em camadas (Controller â†’ Service â†’ ChatClient)
- [ ] Sei criar conversaÃ§Ãµes com histÃ³rico contextual
- [ ] Implementei streaming de respostas em tempo real
- [ ] Configurei rate limiting para proteÃ§Ã£o da API
- [ ] Adicionei mÃ©tricas e monitoramento
- [ ] Implementei cache para otimizaÃ§Ã£o de performance
- [ ] Criei estratÃ©gia de fallback entre modelos
- [ ] Entendo o fluxo completo de uma requisiÃ§Ã£o
- [ ] Sei calcular custos aproximados de tokens
- [ ] Aplico boas prÃ¡ticas de seguranÃ§a (API keys, validaÃ§Ã£o, logs)

---

## ğŸ”— CONECTANDO OS PONTOS

**O que vimos neste capÃ­tulo:**
- Anatomia completa de uma aplicaÃ§Ã£o Spring AI profissional
- Chatbot funcional com conversaÃ§Ãµes contextuais
- Features avanÃ§adas (streaming, rate limiting, cache, fallback)
- Fluxo detalhado de requisiÃ§Ãµes e custos

**O que vem a seguir (CapÃ­tulo 4):**
- Fundamentos profundos: Models, Prompts, Tokens, Responses
- Como escolher o modelo certo para cada caso de uso
- Prompt engineering: transformar perguntas ruins em excelentes
- OtimizaÃ§Ã£o de tokens para reduzir custos

**Projeto DocBot - Estado Atual:**
Agora temos um chatbot robusto com:
- âœ… API REST completa
- âœ… Gerenciamento de conversaÃ§Ãµes
- âœ… Streaming em tempo real
- âœ… ProteÃ§Ãµes de produÃ§Ã£o
- âœ… Observabilidade completa

No prÃ³ximo capÃ­tulo, vamos aprofundar nos **conceitos fundamentais** que tornarÃ£o vocÃª um expert em controlar o comportamento da IA.

---

## ğŸ“ RESUMO EM BULLETS

- **Arquitetura:** Controller â†’ Service â†’ ChatClient (separaÃ§Ã£o clara)
- **ConversaÃ§Ãµes:** Use ConversationManager para manter contexto
- **Streaming:** Flux reativo com Server-Sent Events
- **Rate Limiting:** Bucket4j protege contra abuso (10 req/min default)
- **MÃ©tricas:** Micrometer + Prometheus para observabilidade
- **Cache:** Caffeine reduz latÃªncia e custos em 200x
- **Fallback:** MÃºltiplos modelos garantem resiliÃªncia
- **Custos:** Limite histÃ³rico de conversaÃ§Ãµes (max 10 mensagens)
- **SeguranÃ§a:** Nunca logue conteÃºdo sensÃ­vel de usuÃ¡rios
- **PrÃ³ximo nÃ­vel:** Dominar prompts e tokens

ğŸ’¡ **DICA PRO:** Em produÃ§Ã£o, substitua ConcurrentHashMap por Redis para conversaÃ§Ãµes persistentes e distribuÃ­das.

---

<div style="page-break-after: always;"></div>
